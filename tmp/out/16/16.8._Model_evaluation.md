## 16.8 モデル評価

以下の関数は、モデルを計算するために使用されます。

### 16.8.1 evaluate - 図形を評価する

DCM\_evaluation\_type evaluate( int ng = 0, g\_node\*\* gn = DCM\_NULL,

DCM\_solving\_mode mode = DCM\_STANDARD\_SOLVE );

DCMに対して、図形と変数を再計算し、すべてのエンティティのステータスコードを設定するよう指示します。
この関数には、オプションでDCM図形ノードの配列と、配列の長さに対応する整数を与えることもできます。
これらの使用方法については、以下で説明します。
また、使用する解決モードに影響を与えるためのオプション引数も指定できます。
これには以下の4つの値があります：

- DCM\_STANDARD\_SOLVE \- 標準的な方法を使用して解決します（デフォルト）。図形の配列はソフト参照図形の配列として使用され、配列の最初の図形は最も移動しない可能性があります。
詳細は[2.5.6.7 ソフト参照図形](2.5._Evaluating_the_model.md)を参照してください。
- DCM\_WEIGHTED\_STANDARD\_SOLVE \- この解決モードは、標準的な解決と同様に動作します。
図形の配列は、アプリケーションがその場に残したい図形を定義するために使用されます。
これは標準的な解決のソフト参照配列のように機能しますが、解決された解に対してより大きな影響を与えます。
つまり、図形を移動する可能性は低くなりますが、有効な解を見つける可能性も低くなります。
この解決モードは、evaluate関数と一緒に使用することはお勧めしません。
- DCM\_MINIMUM\_MOVE\_SOLVE \- この解決モードは、出力される変換の数を最小限に抑える傾向があります。
図形の配列は、図形が移動する優先順位を指定するために使用されます。
配列の最初の図形は最も移動する可能性があります。

なお、これはソフト参照とは異なり、配列の最初の図形は最も移動しない可能性がある点に注意してください。
アプリケーションがこの解決モードを使用することを決定した場合、evaluate関数には図形を渡さないことをお勧めします。
- DCM\_LOCALISED\_SOLVE \- この解決モードは、システム内の不満足な制約と変更可能な値を持つ寸法の周りで変更を局所化することを目指します。
詳細は[2.5.6.3 局所化解決モード](2.5._Evaluating_the_model.md)を参照してください。
このモードを使用する場合、アプリケーションは、ほとんどの寸法を剛体にすることを検討することが推奨されます。これは、フラスタム関数DCM\_dimension\_rigidを使用して行います（[17.2.22 DCM\_dimension\_rigid - 距離が剛体であるかどうかを返す](17.2._Basic_dimension_functions.md)を参照）。

なお、図形の配列はすべてソフト参照と見なされます。
これらはすべての図形を移動させる可能性があるため、このモードでは推奨されません。
- DCM\_RELAXATION\_SOLVE \- 拘束不足の図形に対して緩和解法を使用します。
図形の配列はソフト参照として使用されます。

この関数は、以下のいずれかの値を返します：

- DCM\_FULL\_EVAL\- モデル全体に対して完全な評価が実行されました。
- DCM\_EVAL\_ABORTED \- アプリケーションによって評価が中断されました。

異なる解決モードの詳細については、[2\. Fundamental DCM Concepts](2._Fundamental_DCM_Concepts.md)を参照してください。

### 16.8.2 re_evaluate - 図形を逐次的に評価する

DCM\_evaluation\_type re\_evaluate( int ng = 0, g\_node\*\* gn = DCM\_NULL,

DCM\_logical calc\_status = DCM\_FALSE,

DCM\_solving\_mode mode = DCM\_STANDARD\_SOLVE);

この関数は、DCMに対して図形を再計算するよう指示します。
evaluateと同様に、オプションでDCM図形ノードの配列と、配列の長さに対応する整数を指定することもできます。
また、必要に応じて詳細なステータス情報を制御するためのオプション引数も指定できます。
以下にそれらを説明します。

re\_evaluateを使用した逐次的な評価は、evaluateを使用した完全な評価よりも高速です。
これは、DCM評価アルゴリズムの後半部分のみを行えば良いためです（DCMは寸法設定を再分析する必要がありません）。
逐次的な評価は、前回の完全な評価以降に寸法が追加または削除されていない場合に可能です。
変更が行われた場合（たとえば、add\_dやeraseの呼び出しによって）、re\_evaluateを使用すると完全な評価が行われます。
re\_evaluateの引数のいずれかが変更された場合、完全な評価も行われます。

re\_evaluateを使用する前に、reset関数を呼び出すことで、モデル全体の完全な評価を強制することも可能です。

この関数は、以下のいずれかの値を返します：

- DCM\_FULL\_EVAL - モデル全体の完全な評価が行われました。
- DCM\_PARTIALLY\_INCREMENTAL\_EVAL - モデルの一部が逐次的に評価されました。
- DCM\_FULLY\_INCREMENTAL\_EVAL - モデル全体が逐次的に評価されました。
- DCM\_EVAL\_ABORTED - アプリケーションによって評価が中断されました。

通常、寸法の値を変更した後や、change\_chirality関数を使用して異なる解に変更した後に、逐次的な評価が使用されます。
re\_evaluateを使用する場合、これが解のキラリティを変更する唯一の方法です。
逐次的な評価の前に図形を移動しても、解のキラリティには影響しません。
re\_evaluateを使用して寸法の値を変更する場合、寸法は剛体であってはなりません（これがデフォルトです）。
同様に、式に対しては、各ステップで式を変更するためには剛体であってはなりません。

逐次的な評価の前に、アプリケーションが固定された図形を移動してはならず、DCMはこれが行われたかどうかを検出しません。
固定された図形を移動すると、以前の完全な評価の過程で行われた推論が破綻する可能性があります。
図形を移動し、キラリティを保持するための推奨される方法は、move\_and\_evaluate関数です。

デフォルトでは、re\_evaluateはevaluateと同様にステータスコードを設定しますが、未定義および適切に定義された図形を未定義としてマークします。
また、詳細な未定義のステータスコードは図形に設定しません。
オプションの引数calc\_statusをDCM\_TRUEとしてre\_evaluateに渡すと、適切に定義された図形にもステータスコードを設定します。
これを行うと、逐次的な評価にかかる時間は約2倍になりますが、完全な評価にかかる追加時間は約10%増加します。

re\_evaluateには、使用する解法モードを指定するさらなるオプション引数を渡すことも可能です。
許可されるもののリストについては、evaluateを参照してください。
re\_evaluateはevaluateの呼び出しの後に呼び出される場合、同じ解法モードを使用する必要があります。そうでない場合、re\_evaluateは完全な評価を行います。

なお、re\_evaluateによって逐次的な評価が行われた場合、undo\_evaluationを呼び出すことで、図形を逐次的な評価の前の位置または最後の完全な評価が行われた位置にリセットすることができます。

モデル全体または単一のノードがどのように評価されたかを問い合わせるには、セクション[16.5.17 last\_evaluation\_type - DCM評価タイプ情報を返す](16.5._Enquiry_functions.md)で説明されているDCM関数last\_evaluation\_typeを呼び出すことができます。

### 16.8.3 move\_and\_evaluate - 拘束を保持したまま評価する

DCM\_m\_and\_e\_outcome move\_and\_evaluate( int ng, g\_node\*\* gn,

double (\*\*mat)\[3\],

double\* rad = DCM\_NULL, double\* rad2 = DCM\_NULL,

DCM\_solving\_mode = DCM\_WEIGHTED\_STANDARD\_SOLVE );

この関数は、図形を変形して評価することができますが、元の図形位置と同じキラリティで解を見つけます。

この関数は、DCMの図形ノードの配列と、配列の長さに対応する整数を受け取ります。
変換は、変換行列の配列として与えられます。
詳細は、[15.13 DCM transforms](15.13._DCM_transforms.md)を参照してください。
もし、図形が円または楕円である場合、アプリケーションはngの長さのdoubleの配列を与えることもできます。これには、円の新しい半径と楕円の主半径の新しい値が含まれます。
さらに、楕円の副半径の新しい値を与えるために別の配列を使用することもできます。

この関数が呼び出されると、DCMはまず元のキラリティを記録し、アプリケーションが提供した変換と半径に基づいて図形を変更し、同じキラリティで解を求めます。
固定された図形と同じセット内の図形との制約は、移動後にのみ暗示されます。

この関数には、パラメトリックジオメトリ（DCM\_PARAMETRICおよびスプライン曲線）も渡すことができます。
パラメトリック曲線の形状が変わらず、剛体的に移動する場合は、適切な変換を与える必要があります。
ただし、アプリケーションがパラメトリック曲線の形状を変更したい場合は、変更された手順が必要です。

パラメトリック曲線の形状が変更されることをDCMに通知するために、次の手順が実行されます。

- move\_and\_evaluateの呼び出しの開始時に、DCM\_PARAMETRIC曲線のアプリケーション評価器を設定して、曲線の開始位置と形状を返すようにする必要があります。
- スプライン曲線の場合、新しい補間点または制御点がg\_nodesとして指定される場合、アプリケーションはmove\_and\_evaluateを呼び出す前にg\_nodesをDCMに追加する必要があります。
- move\_and\_evaluateを呼び出す際には、次の手順を実行します。

- アプリケーションは、通常どおりDCMのジオメトリポインタをgnのジオメトリ配列に配置します。
- 変換行列の配列matには、パラメトリック曲線または曲線に対応する位置にDCM\_NULLの値を設定する必要があります。
例えば、[15.13 DCM transforms](15.13._DCM_transforms.md)のコードを参照してください。

- move\_and\_evaluate中、DCMは最初にこれらの曲線の開始バージョンを問い合わせ、使用して初期キラリティを確立します。
- ある時点で、DCMはフラスタムに対して、アプリケーションにパラメトリック曲線を所望の最終形状と位置に変更するように要求します。
具体的な呼び出しは、曲線のタイプによって異なります。

- DCM\_PARAMETRIC曲線の場合、フラスタム関数DCM\_parametric\_regenerateが呼び出されます。これは、依存するジオメトリがない曲線でも呼び出されます。この関数が呼び出されるたびに、アプリケーションは曲線の評価器を所望の最終形状に設定する必要があります。通常のように、アプリケーションは変換関数を使用して依存するジオメトリの現在の位置を問い合わせる必要があります。解決プロセス中、DCMはさらにDCM\_parametric\_undo\_regenerateを呼び出して、アプリケーションに一時的に評価器を元の開始形状に戻すように指示する場合があります。
- スプライン曲線の場合、フラスタム関数DCM\_spline\_updateが呼び出されます。その後、アプリケーションはreplace\_splineまたはupdate\_splineのいずれかを呼び出して、対象のスプラインに新しいスプラインデータを提供する必要があります。update\_spline関数は、少ない情報をDCMに渡す必要があるため、細かい変更が必要な場合に使用できます。一方、replace\_spline関数は、制御点や補間点の追加を含むより基本的なプロパティの変更を許可します。2つの関数が許可する変更の詳細については、フラスタム関数の定義を参照してください。

- 新しい曲線定義が提供された後、DCMは新しい曲線の形状と位置を使用して評価を完了します。解が正常に完了できない場合（例：一貫性のないモデルになる場合）でも、パラメトリック曲線の位置は関数中で指定された最終位置となります。
- パラメトリックジオメトリには変換が出力されません。

この関数は、次のいずれかを返します。

- DCM\_M\_AND\_E\_SOLVED\_EXACTLY

すべてのジオメトリが解決され、移動したジオメトリが要求された位置に配置されました。
- DCM\_M\_AND\_E\_SOLVED

すべてのジオメトリが解決されましたが、リストされたジオメトリの一部が要求された位置から移動されました。たとえば、関数に明確に定義された自由ジオメトリのみが渡された場合、解は唯一の解を見つけるためにジオメトリを初期位置に戻す必要があります。
- DCM\_M\_AND\_E\_FAILED

DCMは、ジオメトリを変形した位置でモデルの解を見つけることができませんでした。これは通常、アプリケーションがジオメトリを「あまりにも遠く」移動しようとしたためです。その結果、一部のジオメトリにはNOT\_CHANGEDまたはNOT\_CONSISTENTのステータスコードが付けられます。move\_and\_evaluateに渡された固定ジオメトリは、要求どおりに変形されているため、モデルのキラリティが変わっている可能性があります。この場合、アプリケーションはundo\_evaluationを呼び出してジオメトリの元の状態を復元する必要があります。

なお、この呼び出し中にパラメトリックまたはスプラインの定義がアプリケーションによって変更された場合、undo\_evaluation関数はこの変更を元に戻しません。したがって、パラメトリック曲線の評価器を変更するか、スプライン曲線のreplace\_spline/update\_splineを呼び出すことで、アプリケーションがこれを行う必要があります。

このmove\_and\_evaluate関数は、任意の解決モードを使用することができます。重み付き標準解決モードがデフォルトです。このモードでは、自由ジオメトリを新しい位置に移動し、DCM\_M\_AND\_E\_SOLVED\_EXACTLYを返す可能性が高くなります。

void changed( d\_node\* dn, DCM\_changed\_longevity longevity );

void changed( r\_node\* rn, DCM\_changed\_longevity longevity );

void changed( e\_node\* en, DCM\_changed\_longevity longevity );

void changed( g\_node\* gn, DCM\_changed\_longevity longevity );

void changed( p\_node\* pn, DCM\_changed\_longevity longevity );

これらの関数は、アプリケーションによって寸法値、方程式、または図形ノードが変更されたことをDCMに通知するために使用されます。
これにより、DCMは後続の操作にこれを考慮して、re_evaluateの呼び出しの効率を向上させることができます。

この関数は、変更されるノードと、それがどのように変更されたかを示す引数とともに呼び出されます。
この引数には2つの値があります。

- CHANGED_UNTIL_RE_EVALUATE - re_evaluateの各呼び出しごとに異なるノードが変更される場合に使用されます。
- CHANGED_UNTIL_EVALUATE - 同じノードが繰り返し変更される場合に使用されます。
この値が使用される場合、re_evaluateの呼び出しのシーケンスの開始時に、各ノードに対して一度だけchangedを呼び出す必要があります。

パフォーマンスは、re_evaluate関数が少なくとも2回呼び出される場合にのみ、changed関数を使用することで改善されます。

アプリケーションがこの関数を使用する場合、変更されるすべてのノードに対して呼び出すことが重要です。
つまり、この関数が任意のノードに対して呼び出される場合、他のノードは変更されていないとDCMは仮定します。

この関数は、DCMの外部でモデルを変更した後の増分評価中に実行できない変更を通知するために呼び出された場合、効果はありません（詳細は[2.5.3.3 Incremental evaluation after changing the model outside DCM](2.5._Evaluating_the_model.md)を参照）。

アプリケーションは、ドラッグシーケンス中にd_node（またはr_node）でchangedを呼び出すことができます。
d_nodeにCHANGE_UNTIL_RE_EVALUATEの値でchangedが呼び出された場合、その情報は次のドラッグステップでのみ使用され、その後クリアされます。
CHANGE_UNTIL_EVALUATEが呼び出された場合、次の完全評価後にのみクリアされます。
ドラッグシーケンスの最初の評価は完全評価であり、したがって最初のドラッグステップ後にすべてのchangedステータスがクリアされます。
特に、アプリケーションが「changed」情報をドラッグシーケンス全体で適用したい場合は、最初のドラッグステップの後にchangedを呼び出す必要があります。

この関数は、モデルの大部分が変更されることなく、モデルの一部のみが変化する場合に、増分解決中に重要な最適化を提供します。
ただし、re_evaluateとdynamic_evaluateとの組み合わせでは、モデル全体の初期解決を防ぐことはできません。これにより、初期のドラッグステップが遅くなる場合があります。

局所的な変更に対する解決のさらなる最適化のために、DCMはパーティション固有の解決関数（re_evaluate_partitionsおよびdynamic_evaluate_partitions）を提供しており、指定されたノードを解決するために必要なモデルの一部のみを処理します。

### 16.8.5 リセット - インクリメンタル評価を防止する

void reset( DCM\_logical cancel\_chirality = DCM\_FALSE );

DCMに対して、次にre\_evaluateが呼び出される際にインクリメンタル評価を行わないように指示します。
この関数は、アプリケーションがフル評価を行う必要がある場合に呼び出すことができます。たとえば、解のキラリティを変更するためにジオメトリが移動した場合などです。

この関数には、オプションの論理引数も指定することができます。
これがDCM\_TRUEの場合、change\_chiralityの呼び出しによってキラリティを変更するための保留中のリクエストもすべて削除されます。

### 16.8.6 リセット - 特定のパーティションでの増分評価を防止する

void reset(g\_node\* gn);

void reset(d\_node\* dn);

void reset(r\_node\* rn);

void reset(e\_node\* en);

void reset(v\_node\* vn);

void reset(p\_node\* pn);

これらの関数は、指定されたノードを含むパーティションでの増分評価をDCMに行わないように指示します。

この関数は、アプリケーションがモデルの一部を完全に評価する必要がある場合（たとえば、解のキラリティを変更するためにジオメトリが移動された場合など）に、他のパーティションを増分的に解決するようにDCMに指示するために呼び出すことができます。

### 16.8.7 change\_chirality - キラリティの変更

DCM\_chirality\_status change\_chirality( d\_node\* dn, g\_node\* gn1 = DCM\_NULL ,

      g\_node\* gn2 = DCM\_NULL);

この関数は、解のキラリティを変更するために呼び出されます。
呼び出しは、次の評価関数（evaluate、re\_evaluate、dynamic\_evaluate、move\_and\_evaluate、evaluate\_partitionsなど）の次回呼び出し時に効果が現れます。
変更をまとめて評価する前に、この関数を異なる引数で複数回呼び出すことができます。

DCMの寸法ノードが渡され、オプションで1つまたは2つのDCMの図形ノードが渡されます。
この関数を呼び出すことによる効果は次のとおりです。

- 寸法ノードで呼び出された場合：寸法ノードは数値を持つ距離または方向付き距離の寸法である必要があります。
DCMは、指定された寸法を反転します。
- 寸法ノードと図形ノードで呼び出された場合：図形ノードは円である必要があり、寸法ノードは距離寸法、方向付き距離寸法、共有制約または接線制約である必要があります。
共有制約の場合、他の図形は点である必要があります。
DCMは、寸法の補助点を円の反対側に移動することで、寸法を変更します。
- 寸法ノードと2つの図形ノードで呼び出された場合：
寸法ノードはDCM\_EQUAL\_DISTANCE型であり、2つの図形ノードは等距離制約が追加されたときに使用された図形ノードのペアの1つである必要があります。
等距離制約のキラリティは、change\_chiralityを使用するのではなく、frustum関数[DCM\_equal\_distance\_half\_space](17.2._Basic_dimension_functions.md)を使用して制約された距離の半空間を設定することで最も制御できます。

寸法の状態がD\_OVER\_DEFINED、D\_NON\_ALGEBRAIC、またはD\_NOT\_CHANGEDの場合、モデルは変更されません。

この関数は、与えられた変更が幾何学の相対位置に変化をもたらすかどうかを示す値を返します。
DCMが「評価済み」の状態でない場合（つまり、最後の評価関数の呼び出し以降に何らかの変更が加えられた場合）、変更が発生するかどうかを予測することはできません。
評価済みの状態である場合、キラリティの変更が結果にどのような影響を与えるかを予測しようとします。
返される値は次のとおりです。

- DCM\_CHIRALITY\_UNKNOWN \- 要求されたキラリティの変更が変化を引き起こすかどうかを判断できません。つまり、モデルは評価済みの状態ではありません。
- DCM\_CHIRALITY\_NO\_CHANGE \- 要求により変化は発生しません。例えば、2つの点間の寸法の場合など、単一の解しか存在しない場合に返されます。
- DCM\_CHIRALITY\_CHANGE \- 変化が発生します（ただし、以下を参照）。点と線の距離寸法など、2つの可能な解がある場合に返されます。

DCMが変更が発生する可能性があると示していても、与えられた寸法値では実際の解が存在しない場合があります。
また、DCMが変更が予測されるが、解の対称性のために図形が同じ位置になる場合もあります。
これは、点と線の間のゼロ値の距離寸法の場合などです。

等距離制約が変更されている場合、適切な解が見つかる場合にはDCM\_CHIRALITY\_NO\_CHANGEが返される可能性があります。
これは、change\_chiralityへの呼び出しで指定された特定の図形ノードのペアが等距離の値を定義するために使用される場合に発生します。
等距離で制約されるすべての図形ペアは、1つの図形ノードの間に変数でない距離が存在する場合に変更できます。

関数resetを使用して、キラリティを変更するためのすべての保留中のリクエストをキャンセルすることができます。

### 16.8.8 undo_evaluation - モデルを以前の状態に戻す

void undo_evaluation( DCM_undo_mode um );

図形を以前の状態に戻します。
戻す状態は引数(um)で定義されます。

- DCM_UNDO_TO_INITIAL \- 最後の完全評価の前の位置に戻す。
- DCM_UNDO_TO_PREVIOUS \- 最後の増分評価の前の位置に戻す。

元の変換の逆を使用して、undoを実行します。

最後の評価以降に作成された図形には影響を与えません。
すべてのノードのステータスコードも、以前の状態で保持していた値にリセットされます。

モデルがパーティション固有の解決関数を使用して解決されている場合、図形の以前の位置は各個別のパーティションの状態に応じて設定されます。

### 16.8.9 is\_evaluated – 現在の状態をクエリする

DCM\_evaluated\_outcome is\_evaluated();

この関数は、2D DCMの現在の状態を問い合わせるために使用されます。
モデルが評価された状態である場合、関数はDCM\_EVALUATED\_FULLYを返します。
モデルが最後の評価以降に変更されている場合、関数はDCM\_EVALUATED\_NONEを返します。

パーティション固有の解決が使用されている場合、新しい関数はこれを考慮に入れます。
モデルの一部のパーティションが評価された状態であり、他のパーティションが評価されていない場合、返り値はDCM\_EVALUATED\_PARTIALLYになります。
