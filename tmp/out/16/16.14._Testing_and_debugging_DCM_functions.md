## 16.14 DCM関数のテストとデバッグ

このセクションの関数は、アプリケーションの開発を支援するために設計されています。
また、DCMがアプリケーションに統合された際に発生する可能性のある問題の調査にも使用することができます。

### 16.14.1 journal\_by\_ptr - ファイルへのインターフェースとフラスタム呼び出しのジャーナル記録

DCM\_logical journal\_by\_ptr( DCM2\_file\* fp, unsigned int options =

    DCM\_JOU\_OPT\_ON \| DCM\_JOU\_OPT\_XMIT \|

    DCM\_JOU\_OPT\_XMIT\_START, int p\_segs = 10);

この関数は、指定されたファイルに対してすべてのDCMおよびフラスタム呼び出しのジャーナル記録を開始または停止するために使用されます。
ジャーナル記録を開始する際に、アプリケーションはいくつかのオプションを使用して動作を設定することができます。
ファイルは、アプリケーションによって開かれたファイルストリームへのポインタであるDCM2\_fileオブジェクトによって指定されます。
使用方法については、[16.14.1.2 DCM2\_fileオブジェクト](#_Ref498011414)を参照してください。

変数optionsは、関数にオプションを定義するために使用されます。
詳細については、[16.14.1.3 ジャーナルオプション](#_Ref498013836)を参照してください。
オプションとして、引数p\_segsを使用して、出力ファイルに記録されるパラメトリック曲線のデフォルトの最小セグメント数を変更することもできます。
関数は、呼び出しによってジャーナル記録がオンになった場合はDCM\_TRUEを返し、呼び出しによってジャーナル記録がオフになった場合はDCM\_FALSEを返します。

各DCMのインスタンスには、独自のジャーナル記録状態があります。したがって、複数のDCMインスタンスを持ち、任意の時点でそのうちの1つだけがジャーナル記録を行っていることも、各DCMが異なるジャーナルファイルにジャーナル記録を行っていることも可能です。

なお、DCMの古いバージョン（バージョン68より前）では、ジャーナル記録は単一プロセス内のすべてのDCMインスタンスで共有されるグローバルな状態でした。
しかし、スレッドセーフを確保するために、現在はそうではありません。

ファイルへの書き込みには、異なるオペレーティングシステムによって異なる動作があることに注意してください。
たとえば、後のWindowsランタイムライブラリでは、ファイルを閉じた後にFILE\*に書き込みを試みると例外がスローされます（閉じられたファイルハンドルに書き込みを試みる）。
他のOSバージョンでは、この動作は黙って無視されます。

また、注意すべき点として、journal\_by\_ptr / journal\_by\_nameのいずれかを呼び出してジャーナル記録を開始し、他の関数を呼び出してジャーナル記録を停止することが可能ですが（推奨されません）、単一のDCMインスタンス内部には1つのジャーナル記録状態しかありません。

#### 16.14.1.1 ジャーナルファイルの内容

ジャーナルファイルには、ジャーナリングが開始された時点からDCMの相互作用のすべての詳細と、さまざまなキーステージでのモデルデータが含まれます。
このデータは、単一のDCMインスタンスに固有です。複数の同時DCMインスタンスを使用するアプリケーションは、必要に応じてそれぞれでジャーナリングを有効にする必要があります。
この場合、異なるジャーナルファイルをそれぞれ使用することが推奨されています。

セッション内でジャーナルファイルを変更したり、以前のファイルに戻ってジャーナリングを続けることも可能です。
これを行うには、ジャーナル機能を2回呼び出す必要があります。1回目は最初のファイルへのジャーナリングを停止し、2回目は新しいファイルでのジャーナリングを開始するためです。

ジャーナルファイルに含まれる情報は以下の通りです：

- DCMのバージョンとプラットフォーム環境を識別するヘッダーセクション
- 呼び出しのシーケンス番号。
1から始まり、ジャーナリングがオフになっていてもシーケンス番号は増加します。シーケンス番号は各DCMインスタンスに固有です。
- 呼び出される次元システムを示す識別子。
- 呼び出される関数の名前。オーバーロードされたC++関数には対応するCインターフェース名が使用されます。
- 関数の引数。
ポインタは先頭に%記号が付き、配列は角かっこで囲まれ、DCMの型はテキストで出力されます。
- 返り値。
- ジャーナリングオプションに応じてモデルデータ（送信ファイル）。
- 関数内での経過時間。
これは、遅いフラスタム呼び出しを特定することで、統合に関するパフォーマンスの問題を検出するために使用される場合があります。

ジャーナル\_by\_ptrを使用すると、アプリケーションはDCMの呼び出しの間に独自のデータをジャーナルファイルに書き込むことができます。
これは、特定のDCMの呼び出しが行われるときにどのアプリケーション操作が行われているかを示す有用な方法であり、デバッグの問題解決に非常に役立ちます。
このようなデータは、テキストの各行の先頭に"#"記号を付ける必要があります。これにより、ジャーナルファイルがD-Cubed Componentsのデバッグツール（Analyseテストハーネスを含む）を介して自動的に処理される場合、これらの行は自動的に無視されます。

#### 16.14.1.2 DCM2\_fileオブジェクト

ファイル名を指定する代わりに、DCMはアプリケーションがDCM2\_file型の構造体を作成して渡すことも可能です。
これにより、より柔軟性と制御が可能になります。
特に、複数のソースからのジャーナルデータを同じファイルに書き込むことができます。

構造体の定義は以下の通りです：

typedef struct DCM2\_file {

FILE\* file;

DCM2\_fwrite\_function fwrite;

DCM2\_fflush\_function fflush;

} DCM2\_file\_object;

これらは次のようになります：

- file - これはCのfopen関数によって返されたポインタです。
ファイルは書き込みアクセスで開かれている必要があります。
- fwrite - これはDCMがジャーナルファイルに書き込むために使用する関数へのポインタです。
次のように定義されています：

typedef int (\*DCM2\_fwrite\_function) (const void\* buffer, size\_t size,

size\_t count, FILE\* file);
- fflush - これはDCMが保留中のデータをジャーナルファイルに書き込むために使用する関数へのポインタです。
次のように定義されています：

typedef int (\*DCM2\_fflush\_function)( FILE\* file );

DCM2\_file構造体は、次の便利なメソッドを使用して作成することをおすすめします：

- #define DCM2\_file\_construct(file\_obj, file\_ptr) \

DCM2\_file\_construct\_full(file\_obj, file\_ptr, &fwrite, &fflush)

これは、ローカル関数fwriteとfflushを使用してDCM2\_file構造体を作成するマクロです。
- DCM2\_file\* DCM2\_file\_construct\_full(DCM2\_file\* file\_obj, FILE\* file,

DCM2\_fwrite\_function fwrite, DCM2\_fflush\_function fflush)

これは、指定された関数を使用してDCM2\_file構造体を作成する関数です。

#### 16.14.1.3 ジャーナリングオプション

journal\_by\_ptr関数とjournal\_by\_name関数を使用すると、アプリケーションはジャーナルファイルに書き込まれる内容を指定するためのビットマスクを渡すことができます。
整数のoptsは、以下の列挙型の合計です。

typedef enum DCM\_journal\_options{

DCM\_JOU\_OPT\_OFF= 0x00000000,

DCM\_JOU\_OPT\_ON= 0x00000001,

DCM\_JOU\_OPT\_XMIT= 0x00000002,

DCM\_JOU\_OPT\_XMIT\_INC= 0x00000004,

DCM\_JOU\_OPT\_XMIT\_START= 0x00000008,

DCM\_JOU\_OPT\_FRU\_OFF= 0x00000010,

DCM\_JOU\_OPT\_MATHS\_FRU\_ON= 0x00000020,

DCM\_JOU\_OPT\_FLUSH\_OFF= 0x00000040,

} DCM\_journal\_options;

各列挙型によって有効になる機能は以下の通りです：

- DCM\_JOU\_OPT\_OFF \- ジャーナリングをオフにします。
- DCM\_JOU\_OPT\_ON \- ジャーナリングをオンにします。
- DCM\_JOU\_OPT\_XMIT \- DCMが完全評価を行う直前にモデルデータを出力します。
これにはドラッグシーケンスの最初の評価（dynamic\_evaluate）またはre\_evaluateからの完全評価が含まれます。
- DCM\_JOU\_OPT\_XMIT\_INC \- DCMが増分評価（ドラッグなど）を行う直前にモデルデータを出力します。このオプションは、dynamic\_evaluateまたはre\_evaluate関数の2回目以降の呼び出しで埋め込み送信ファイルを取得するために設定する必要があります。
- DCM\_JOU\_OPT\_XMIT\_START \- ジャーナリングが開始されるときに既存のモデルデータを出力します。
ジャーナルが最も有用になるようにするために、モデルデータがDCMに追加される前にジャーナリングが有効になっていることが強く推奨されます。
ただし、モデルデータがシステムに存在する場合、このフラグを設定すると、DCMはそのデータを示す埋め込み送信ファイルを作成します。

このオプションが設定されているかどうかに関係なく、ジャーナルファイルには、ジャーナリングが作成されたときにDCMインスタンス内の既存ノードの数をリストアップする警告が含まれます（非空の場合）。
- DCM\_JOU\_OPT\_FRU\_OFF – フラスタム関数呼び出しのジャーナリングを無効にします。
このオプションはファイルサイズを削減するために使用できますが、問題を報告するためのファイル作成には使用しないでください。
- DCM\_JOU\_OPT\_MATHS\_FRU\_ON – 登録された外部LAPACK数学ライブラリのジャーナリングを有効にします。
このオプションは非常に大きなジャーナルファイルを生成し、DCubed Componentsサポートチームのメンバーからの要求がある場合にのみ有効にする必要があります。
- DCM\_JOU\_OPT\_FLUSH\_OFF – ジャーナルバッファの1行ずつのフラッシュをオフにします。

DCMのジャーナリングのデフォルトモードは、各行のバッファのフラッシュであり、ジャーナルファイル内でDCMとフラスタムへの呼び出しをできるだけ多くキャプチャすることができます。

このオプションは、書き込み時間が遅い場合（ほとんどのシステムでネットワークファイルに書き込む場合など）に有効にすることができます。通常の状況では、各行のフラッシュは効率的です。

DCMの相互作用に関するクラッシュや例外を報告する顧客は、ジャーナルファイルができるだけ完全であるように、このオプションが設定されていないことを確認する必要があります。

#### 16.14.1.4 コードの例

以下は、アプリケーションがデフォルトのオプションとパラメトリックセグメントの数を使用して、ファイルdcm2.jouにジャーナリングをオンにする方法を示しています。

// 新しい寸法システムを作成する

dsp = new DCM2\_dimension\_system;

// ジャーナリングをオンにする

DCM2\_file jou\_file;

DCM2\_file\_construct(&jou\_file, fopen("dcm2.jou","w"));

if (jou\_file.file)

dsp->journal\_by\_ptr(&jou\_file);

else

cout << "\*\*\* ジャーナルファイルを開くことができませんでした" << endl2;

ジャーナリングを停止するには、DCM\_JOU\_OPT\_OFFビットを設定してjournal\_by\_ptrを呼び出すことも可能ですが、DCMインスタンスが削除されるときにジャーナリングをオンのままにしておくことが推奨されます。
DCMはデストラクタ内でジャーナリングをオフにしますが、その前に残っているDCMオブジェクトの消去をジャーナルに記録するため、有用なデバッグ情報を提供することがあります。

DCMデストラクタがジャーナリングをオフにすることを推奨している場合、DCMが使用するFILE\*がDCMデストラクタが呼び出される前に閉じられないようにすることが重要です。そうしないと、システム例外が発生する可能性があります。

#### 16.14.1.5 埋め込まれた送信ファイル

DCM\_JOU\_OPT\_XMIT\_\* オプションと組み合わせて使用する場合、ジャーナルファイルにはDCMのモデル状態のスナップショットを表す埋め込まれた送信ファイルのセクションが含まれます。
これらのセクションは、debug\_xmit関数によって生成されるファイルと同等です。

これらの領域は常に次の形式の2つの行の間に挿入されます：

#XMIT 開始 transmit\_description

#XMIT END

これらの2つの行の間のデータは、D-Cubed Components Analyseテストプログラムで読み込むことができる.xmtファイルに抽出して保存することができます。

transmit\_descriptionの特定の文字列は、特定の操作の「開始」または「終了」を示し、操作識別子（例：「re\_eval」または「eval」）を含み、そのタイプの呼び出しのうちどの呼び出しであるかを示す整数の接尾辞が付いています。

したがって、完全なre\_evaluateの後に2つのドラッグステップと最後の完全なre\_evaluateが含まれるセッションのジャーナルの場合、ジャーナルオプションにDCM\_JOU\_XMIT\_INCとDCM\_JOU\_OPT\_XMIT\_INCが含まれている場合、次のラベルが埋め込まれたトランスミットがあるはずです：

- start\_re\_eval\_1
- start\_dyn\_eval\_1
- end\_dyn\_eval\_1
- start\_dyn\_eval\_2
- end\_dyn\_eval\_2
- start\_re\_eval\_2
- start\_dyn\_eval\_2

トランスミットファイルの詳細については、[16.14.2 debug\_xmit - DCMからトランスミットファイルを書き込む](#_Ref497988449)を参照してください。

### 16.14.2 debug\_xmit - DCMから送信ファイルを書き込む

DCM\_logical debug\_xmit( const char\* f\_name = "dcmdebug.xmt", int p\_segs = 10,

       DCM\_logical do\_flush = DCM\_TRUE );

この関数は、アプリケーションがDCMに現在保持されているデータに対応する送信ファイルを書き出すために提供されています。
このファイルは、Analyseユーザーインターフェースで読み込むことができます。
これは、アプリケーションのデバッグやDCMの問題の調査のための方法として役立ちます。

- f\_nameは作成される送信ファイルの名前です。
デフォルトのファイル名はdcmdebug.xmtです。
このファイルは既に存在する場合は上書きされます。
DCMがこのファイルを開けない場合、関数はDCM\_FALSEを返し、それ以外の場合はDCM\_TRUEを返します。
- p\_segsは、出力ファイルに記録されるパラメトリック曲線の最小セグメント数を定義します。
セグメント数はゼロより大きくなければならず、デフォルト値は10です。
- do\_flushは、各行が書き込まれた後にジャーナルバッファをフラッシュするかどうかのスイッチです。
オフにするとパフォーマンスが向上する可能性がありますが、その場合、生成されるジャーナルファイルは不完全になる可能性があります。
デバッグ目的では、各行の後にフラッシュすることが有用です。これにより、利用可能な情報がジャーナルに書き込まれます。例えば、クラッシュが発生した場合などです。

この方法で生成される送信ファイルには、DCMが知っている情報のみが含まれます。
すべての行は非制約であり、円弧は完全な円になります。
寸法はデフォルトの位置に配置されます。
非線形方程式の形式はDCMにはわかりませんので、非線形方程式ではf(v1,v3,v7)=0の形式で出力されます。ここで、v1、v3、v7は非線形方程式の変数です。

この方法で生成されるファイルは、アプリケーションのデバッグを支援するためにのみ意図されています。
アプリケーションは、これらのファイルをデータの保存方法として使用すべきではありません。

この関数は、主に例題コードとの初期統合で有用です。
この関数の使用は、本番アプリケーションでは推奨されません（デバッグモードでも）：ほとんどの場合、単独のdebug\_xmit関数ではなく、埋め込まれた送信ファイルを含むジャーナルファイルを作成するためにjournal\_by\_ptr関数を使用する方がより便利です。
ジャーナルファイルにはモデルデータのコンテキストが表示され、D-Cubed Componentsサポートに渡すと問題が再現される可能性が高くなります。
journal\_by\_ptrメソッドの利点は、アプリケーションがファイルシステムへのアクセスを制御できることです。

### 16.14.3 journal\_by\_name - 名前付きファイルへの書き込みインターフェースとフラスタム呼び出し

DCM\_logical journal\_by\_name( const char\* file\_name,

unsigned int opt = DCM\_JOU\_OPT\_ON \| DCM\_JOU\_OPT\_XMIT \|

     DCM\_JOU\_OPT\_XMIT\_START, int p\_segs = 10 );

この関数は、journal\_by\_ptr関数の代替です。
違いは、この場合DCMにファイルのオープンとクローズの操作を行うように依頼することです。
ほとんどの場合、journal\_by\_ptr関数を使用する方が好ましいです。なぜなら、これによりアプリケーションはファイルシステムとのやり取りに完全な制御を持つことができ、また独自のコメントを追加するためにジャーナルファイルにアクセスすることもできます。
ただし、特定のプラットフォームでは、journal\_by\_nameが好ましい場合もあります。

この関数は、指定されたファイルに対してすべてのDCMおよびフラスタム呼び出しのジャーナリングを開始または停止するために使用されます。
ジャーナリングを開始する際、アプリケーションはいくつかのオプションを使用して動作を設定することができます。
ファイルは以下のように指定されます。

- ファイル名（パスを含む）file\_name。
2D DCMバージョン67以降では、DCMは指定されたファイル名をそのまま使用します。
アプリケーションは、ファイル名とパスがDCMを含むプロセスに書き込み可能であることを確認する責任があります。

変数optは、関数にオプションを定義するために使用されます。
詳細については、[16.14.1.3 ジャーナリングオプション](#_Ref498013836)を参照してください。
オプションとして、引数p\_segsを使用して、出力ファイルに記録されるパラメトリック曲線のデフォルトの最小セグメント数を変更することもできます。
関数は、呼び出しによってジャーナリングがオンになった場合はDCM\_TRUEを返し、呼び出しによってジャーナリングがオフになった場合はDCM\_FALSEを返します。

各DCMインスタンスには独自のジャーナリング状態があります。したがって、複数のDCMインスタンスを持ち、任意の時点でそのうちの1つだけをジャーナリングすることができます。また、各DCMは異なるジャーナルファイルにジャーナリングすることもできます。

journal\_by\_nameでは、同じファイルに2つのDCMインスタンスが同時にジャーナリング情報を書き込むことはできません。
関数が他のDCMインスタンスで書き込み用に現在開かれているファイル名で呼び出された場合、DCMは新しいファイルとして開こうとしますが、追記しようとすることはできません。なぜなら、他のDCMインスタンスについての知識を持っていないからです。
これの結果は次のとおりです。

なお、古いバージョンのDCM（バージョン68より前）では、ジャーナリングは単一のプロセス内のすべてのDCMインスタンスで共有されるグローバルな状態でした。
これはもはやそのような状態ではありません（スレッドセーフを確保するため）。

journal\_by\_ptr / journal\_by\_nameのいずれかを呼び出してジャーナリングを開始し、他の関数を呼び出して停止することは可能ですが（推奨されません）、単一のDCMインスタンス内部には1つのジャーナリング状態しかありません。

journal\_by\_nameを使用する場合、DCMは単一のセッション（DCMオブジェクト/インスタンスの寿命）中に使用されたファイルの履歴を保存します。セッション中にファイルが使用されていない場合、同じ名前の既存のファイルを上書きします。
ただし、セッション中にファイルが使用された場合、DCMはジャーナリング情報を追記します。

### 16.14.4 ジャーナル - すべてのインターフェースとフラスタムの呼び出しとデータをファイルに書き込む

DCM\_logical journal ( const char\* file = "dcm.jou" );

この関数は、相互作用をジャーナルに記録しますが、出力にモデルデータは追加しません。
デフォルトは、現在のディレクトリにあるファイルdcm.jouです。
この関数は、journal\_by\_nameとjournal\_by\_ptrによって置き換えられました。

### 16.14.5 set\_label – DCMノードにテキスト文字列を添付する

void set\_label(g\_node\* n, const char\* label);

void set\_label(d\_node\* n, const char\* label);

void set\_label(r\_node\* n, const char\* label);

void set\_label(v\_node\* n, const char\* label);

void set\_label(e\_node\* n, const char\* label);

void set\_label(p\_node\* n, const char\* label);

set\_label関数は、アプリケーションがDCMノードに保存するテキスト文字列を指定することを可能にします。
この文字列は、ジャーナルとdebug\_xmit関数によって書き出されます。
この文字列は、問題が発生した場合に技術サポートチームに問題のジオメトリや拘束条件を特定するために使用することができます。

各関数では、アプリケーションはDCMノードnへのポインタと、labelのいずれかを渡す必要があります：

- 指定されたノードのテキストラベルとして使用されるCスタイルの文字列へのポインタ
- 指定されたノードからラベルを削除するためのNULLポインタ

安全上の理由から、v74以降のDCMでは、ノードラベルの最大文字数が256文字（文字列終端子'\\0'を含む）までコピーして保存します。

アプリケーションがより長い配列へのポインタを渡した場合、保存される文字列は、終端子'\\0'に続く3つの'.'文字で終了します。

同様に、アプリケーションが制御文字を含む配列へのポインタを渡した場合、長さが256未満であっても、DCMは制御文字で切り詰め、終端子'\\0'で置き換えます。

したがって、256文字を超える文字列や制御文字を含む文字列を使用する場合、アプリケーションはDCMに保存されるラベルが入力として与えられたものと比べて切り詰められる可能性があることに注意する必要があります。

デバッグ目的でのラベルの重要性から、ジャーナルファイルでのset\_labelの最初の呼び出しでは、制御文字を含む入力文字列を含む完全な文字列が出力されます。この場合、上限は2048文字です。
2回目の呼び出しでは、DCMに保存されたラベルが出力されます。
これにより、切り詰めプロセスが発生した場合に完全な可視性が提供されます。
