## 16.5 Enquiry functions

The following functions are used to enquire the status code or any other information from the DCM.

### 16.5.1 status - Gives the status of a node in the DCM

g\_node\_status status( g\_node\* gn );

d\_node\_status status( d\_node\* dn );

d\_node\_status status( r\_node\* rn );

d\_node\_status status( e\_node\* en );

g\_node\_status status( v\_node\* vn );

g\_node\_status status( p\_node\* pn );

Takes a pointer to a node in the DCM and returns a status code. 
The status codes are specified in the DCM header. 
See chapter [14\. Status Codes](14._Status_Codes.md)
Note that status information is also output from the Frustum as described in chapter [17\. The Frustum Interface](17._The_Frustum_Interface.md)

Status codes are only guaranteed to be valid immediately after an evaluation. 
If the application subsequently makes changes to the model most status codes will not be updated until after the next evaluation.

More detailed information about geometries that are under-constrained is provided by the function underdefined\_status described below.

### 16.5.2 underdefined\_status - Output degrees of freedom information

int underdefined\_status( g\_node\* gn );

Returns extra information about an under-defined geometry following an evaluation. 
An under-defined geometry may have several remaining degrees of freedom. 
In addition it may have the property of being under-defined due to a singular model configuration.

The function returns an integer value that is the sum of the values of the following codes.

- DCM\_RADIUS\_UNDERDEFINED \- Returned only for circles.
- DCM\_MAJOR\_RADIUS\_UNDERDEFINED \- Returned only for ellipses.
- DCM\_MINOR\_RADIUS\_UNDERDEFINED \- Returned only for ellipses.
- DCM\_ANGLE\_UNDERDEFINED \- For lines, ellipses, parametrics, sets and the first direction of 2D patterns.
- DCM\_POSITION\_UNDERDEFINED \- For any geometry, including sets.
- DCM\_ANGLE2\_UNDERDEFINED \- For the second direction of 2D patterns.
- DCM\_SCALE\_UNDERDEFINED \- For scalable, uni-scalable and bi-scalable sets. 
Note that this status is not used for splines, instead, the "G\_SUPPORTS" versions of the codes are used.
- DCM\_SCALE2\_UNDERDEFINED – For bi-scalable sets. 
Not used for bi-scalable splines.
- DCM\_SINGULAR\_UNDERDEFINED \- This code indicates that the g\_node is singular under-defined because of a singular configuration in the model. 
If a g\_node has this status then adding constraints to it will usually make it over-defined, rather than well-defined. 
To allow the geometry to be fully defined, it is necessary to change the way it is constrained: Either by changing to an alternative constraint scheme or by changing the values of dimensions.
- DCM\_SINGULAR\_UNDERDEFINED\_INDIRECT \- This additional code indicates that the g\_node is not directly constrained by singular constraints or dimensions. 
If there are multiple g\_nodes in the model that have the DCM\_SINGULAR\_UNDERDEFINED status, then the application should address the ones that don not have this status first.
- DCM\_PATTERN\_VALUE\_UNDERDEFINED \- For the first value of 2D patterns or 1D patterns (linear or rotational).
- DCM\_PATTERN2\_VALUE\_UNDERDEFINED \- For the second value of 2D patterns.
- DCM\_OFFSET\_DISTANCE\_UNDERDEFINED \- For offset parametrics.
- DCM\_ RHO\_UNDERDEFINED \- For conics whose rho value has not been defined.
- DCM\_G\_SUPPORTS\_\* \- Codes for parametrics, including splines. 
The term G\_SUPPORTS indicates that for these curves, DCM has diagnosed the freedoms using the geometry that defines the shape fo the curve. 
For spline geometry, however, there may be no actual additional g\_nodes, the status will simply indicate the freedoms of the spline g\_node itself. 
For regenerated parametrics, the supports are the geometry constrained via dependence constraints.

- DCM\_G\_SUPPORTS\_UNDERDEFINED \- For parametric curves with at least one under-defined support. 
Typically this indicates the shape can change.

- DCM\_V\_SUPPORTS\_UNDERDEFINED \- For parametric curves that depend on one or more under-defined v\_node (variables).

- DCM\_G\_SUPPORTS\_RIGID\_ANGLE\_UNDERDEFINED – Indicates that the curve can rotate rigidly. 
The supporting geometry has been diagnosed to be well-defined with repect to each other.

- DCM\_G\_SUPPORTS\_RIGID\_POSITION\_UNDERDEFINED – Indicates that the curve can translate rigidly. 
The supporting geometry has been diagnosed to be well-defined with repect to each other.

- DCM\_G\_SUPPORTS\_SCALABLE\_SCALE\_UNDERDEFINED – Indicates that the curve can be scaled. 
For the majority of cases, this will indicate an isotropic, or uniform, scaling.However, for bi- or uni-scalable splines, or cases involving sets of these types, this status may be used where the geometry can scale in an affine manner, i.e. 
changing in only one direction, not all direcitons.

- DCM\_G\_SUPPORTS\_SCALABLE\_ANGLE\_UNDERDEFINED – Indicates that the supports suggest that the curve can change scale and rotate.

- DCM\_G\_SUPPORTS\_SCALABLE\_POSITION\_UNDERDEFINED – Indicates that the curve should be able to scale and to translate.

- DCM\_G\_SUPPORTS\_SCALABLE\_SCALE2\_UNDERDEFINED – Used when DCM has detected that the curve’s supports, or the spline, can be scaled in two separate orthogonal directions, typically a bi-scalable spline curve, or with the dependent geometry in a bi-scalable set. 
If this value is set when the corresponding DCM\_G\_SUPPORTS\_SCALABLE\_SCALE\_UNDERDEFINED is not set then this indicates that the primary scaling direction is well-defined, but the orthogonal direction can still scale.

Thus, if a line has both positional and rotational freedoms the function will return DCM\_ANGLE\_UNDERDEFINED + DCM\_POSITION\_UNDERDEFINED (8 + 16 = 24). Note that for a line the function will never return DCM\_ANGLE\_UNDERDEFINED (8). It can only return DCM\_POSITION\_UNDERDEFINED (positional freedom only, when angle is constrained) or DCM\_ANGLE\_UNDERDEFINED + DCM\_POSITION\_UNDERDEFINED (angle and position under-defined) – this is returned even if there is only a single freedom for the line.

If the status of the geometry is not G\_UNDER\_DEFINED the function will return zero.

Note: The code DCM\_SINGULAR\_UNDERDEFINED\_INDIRECT will only be set on geometry that also has the code DCM\_SINGULAR\_UNDERDEFINED. 
If an application wishes simply to flag under-defined geometry that cannot be fully defined, the DCM\_SINGULAR\_UNDERDEFINED status is the value to check.

Note that in general any g\_node that is identified as under-defined due to a singular configuration will also have additional under-defined status bits set to indicate the details of which remaining freedoms it has (in the return value of underdefined\_status). The detailed under-defined status codes for geometry is not guaranteed to return a minimal set of freedoms – in some cases the DCM be unable to identify whether a single freedom is a positional or angular freedom, for example, so both the relevant flags are set. 
To get a more accurate description of the remaining freedoms of a geometry, the underdefined\_dof function can be used. 
That is a more expensive calculation, however.

Further details about this facility are given in the chapter [2\. Fundamental DCM Concepts](2._Fundamental_DCM_Concepts.md)

### 16.5.3 underdefined\_dof – Degrees of freedom information of geometry

DCM\_dof\_result\_status underdefined\_dof( g\_node\* gn,

    int\* n\_rot,

    int\* n\_trans,

    DCM\_logical\* internal1,

    DCM\_logical\* internal2,

    DCM\_dof\_info\_type\* info\_type,

    double extra\_info\[2\],

     DCM\_dof\_info\_type\* info2\_type = DCM\_NULL,

    double extra\_info2\[2\] = DCM\_NULL );

Takes a pointer to a DCM geometry node. 
This function returns details of the remaining freedoms of the geometry. 
The function should only be called on an evaluated model. 
The DCM will only calculate the degrees of freedom information during a call to evaluate, move\_and\_evaluate or to re\_evaluate if the option calc\_status is set to DCM\_TRUE. 
The function cannot be used after dynamic\_evaluate. 
The return value is a status indicating whether it was successful which is one of:

- DCM\_DOF\_NOT\_EVALUATED – No information available, evaluation required.
- DCM\_DOF\_UNKNOWN – Returned when DCM cannot determine the degrees of freedom. 
This will be because either:

- The g\_node has not been solved (i.e. 
over-defined or not-consistent).
- The g\_node type is not supported. 
Currently, these are: DCM\_PARAMETRIC, DCM\_SPLINE, DCM\_SCALABLE\_SET, DCM\_UNI\_SCALABLE\_SET, DCM\_BI\_SCALABLE\_SET and 1D and 2D pattern reference nodes.
- The g\_node is a set (DCM\_SET), and the arguments info2\_type and extra\_info2 are NULL.

- DCM\_DOF\_SUCCESS – Function successful.

The behaviour of this command differs depending on whether the g\_node is a regular geometry or a rigid set, as detailed in the following two subsections.

#### 16.5.3.1 underdefined\_dof: Geometry g\_node

The DCM will identify the following freedoms for a geometry g\_node:

- In n\_rot, the number of rotational freedoms of the geometry. 
This can be 0 or 1.
- In n\_trans, the number of translational freedoms of the geometry. 
This can be 0, 1 or 2.
- In internal1, whether the radius of a circle or the major radius of an ellipse is under-defined. 
Set to DCM\_FALSE for all other geometry.
- In internal2, whether the minor radius of an ellipse is under-defined. 
Set to DCM\_FALSE for all other geometry.

If the geometry has only a single non-radial freedom (i.e., n\_rot+n\_trans==1) then the DCM will return additional details about the freedom in info\_type and extra\_info. 
Alternatively, for an ellipse with rotational and translational freedoms, additional details will be available with respect to the translational freedom in info\_type and extra\_info.

The type of information returned is specified by info\_type as one of:

- DCM\_DOF\_NO\_INFO – No information provided. 
Used unless there is only one external freedom. 
In this case, the extra\_info array will not be filled.
- DCM\_DOF\_ROT\_CENTRE – The DCM has identified that the geometry is free to rotate about a well-defined position, e.g. 
a line tangent to a well-defined circle. 
This centre of rotation is returned in the vector extra\_info. 
N.B. 
Geometry types with rotational symmetry (point, circle), could equally be considered to translate to such a position and will therefore be given the status DCM\_DOF\_TRANS\_AROUND in preference to this status.
- DCM\_DOF\_TRANS\_DIRECTION \- The DCM has identified that the geometry is free to translate in a well-defined direction. 
This direction is returned in the vector extra\_info.
- DCM\_DOF\_TRANS\_INST\_DIRECTION \- The DCM has identified that the geometry is constrained to follow a path defined by a parametric curve. 
The instantaneous direction, returned in the vector extra\_info, is the direction in which the geometry can begin to translate, i.e. 
the tangent direction of the path to which the geometry is constrained.
- DCM\_DOF\_TRANS\_AROUND – The DCM has identified that the geometry is constrained to translate around a well-defined position, defined by the extra\_info vector. 
For example, an ellipse constrained parallel to a fixed line and concentric to a free point on a fixed circle would have this status. 
N.B. 
This status is also given to the point in this example.

#### 16.5.3.2 underdefined\_dof: Rigid set g\_node

When called with a pointer to a rigid set, the DCM will identify the following freedoms:

- In n\_rot, the number of rotational freedoms of the set. 
This can be 0 or 1.
- In n\_trans, the number of translational freedoms of the set. 
This can be 0, 1 or 2.
- The arguments internal1 and internal2 will be set to DCM\_FALSE, as no internal freedoms are available for a rigid set.

In addition, for sets with either 1 or 2 degrees of freedom, the DCM will return details of the nature of each of the freedoms identified using the remaining arguments. 
The arguments info\_type and info2\_type are used to identify the type of freedom that has been determined and the corresponding arguments extra\_info and extra\_info2 are used to provide geometrical details, in the form of positions or directions.

The degrees of freedom information types have the following meanings for sets:

- DCM\_DOF\_NO\_INFO – No information provided. 
Used either when there is no freedom corresponding to the field, or in a case where the DCM cannot determine details for the freedom. 
When this value is set, the corresponding vector extra\_info or extra\_info2 will not be filled.
- DCM\_DOF\_ROT\_CENTRE – The DCM has identified that the set is free to rotate about a well-defined position. 
This centre of rotation is returned in the corresponding vector. 
When a set has this status, all geometry will rotate about the same centre if the freedom is exercised.
- DCM\_DOF\_TRANS\_DIRECTION \- The DCM has identified that the set is free to translate in a well-defined direction. 
This direction is returned in the corresponding vector.
- DCM\_DOF\_TRANS\_INST\_DIRECTION \- The DCM has identified that the set is constrained to follow a path defined by a curve (other than a circle or line). The instantaneous direction, returned in the vector, is the direction in which the set can begin to translate, i.e. 
the tangent direction of the path to which the set is constrained.
- DCM\_DOF\_TRANS\_AROUND – The DCM has identified that the set is constrained to translate around a well-defined position, defined by the corresponding vector. 
When this situation is identified, the DCM will also provide the position in the set which is rotating about the centre. 
The value of info\_type will be DCM\_DOF\_POSITION. 
For example, a set containing a point constrained to a fixed circle, with another geometry parallel to a fixed direction would have this status.
- DCM\_DOF\_TRANS\_FREE\_DIRECTION – This type will be used for a rigid set that has two independent freedoms, where one of the freedoms is a translation that is currently in the specified direction, but which is free to change as the other, rotational freedom is exercised. 
See example case 2 below.
- DCM\_DOF\_ROT\_FREE\_CENTRE – This type will be used for a rigid set that has two freedoms, where one of the freedoms is a rotation about a point in the set where that point has a freedom to translate. 
The corresponding info field will provide the current location about which the set can rotate.
- DCM\_DOF\_FREE\_POSITION – Used to identify the position within a rigid set which is constrained to translate about a fixed position. 
See DCM\_DOF\_TRANS\_AROUND above.

In the above types, the term FREE is used to describe a freedom which can be exercised independently of another freedom of the set. 
That means that if the set is translated along a free direction for a finite distance, it will still have the freedom to translate in that direction.

The term INST, for instantaneous, indicates a freedom that is cannot be exercised over a finite distance in the same direction or about the same point – the act of exercising the freedom causes the direction or centre of the freedom to change dynamically.

Where neither INST nor FREE appears in the type, the freedom identified is about a well-defined centre or in a well-defined direction.

For certain sets with two translational degrees of freedom (n\_trans=2) no extra information is required about these freedoms so the info\_type and info2\_type fields will be DCM\_DOF\_NO\_INFO. 
Similarly, for well-defined or fixed sets (n\_trans=0, n\_rot=0) there will be no freedoms to describe.

For sets with one translational and one rotational freedom, both extra\_info fields will generally be filled with information. 
Examples of cases that can arise include:

Case 1

Case 2

Case 3

Description

No rotation, translates along a fixed direction

Translates along a direction which rotates around a fixed centre.

Rotates around a centre which translates around a fixed point.

Example configuration

A set contains a line that is constrained coincident to a fixed line

Set containing a line which is constrained tangent to a fixed circle.

Set containing a point which is constrained coincident to a fixed circle

Freedoms

n\_rot = 0

n\_trans = 1

n\_rot = 1

n\_trans = 1

n\_rot = 1

n\_trans = 1

Info (\_ type, vector)

\_TRANS\_DIRECTION

The direction of the fixed line

\_TRANS\_FREE\_DIRECTION

Current direction of the line in the set

\_ROT\_FREE\_CENTRE

Current position of the point in the set

Info2 (type, vector)

\_NO\_INFO

Not set

\_ROT\_CENTRE

Centre of the fixed circle

\_TRANS\_AROUND

Centre of the fixed circle

Table 7: Degrees of freedom information for sets

In all the cases above, the positions and directions of geometry given in the extra information vectors relate to the positions during the most recent evaluate. 
As soon as any change is made to the geometry or DCM model, the information calculated by DCM in this function would be invalidated.

The use of the underdefined\_dof function for non-set geometry remains unchanged from earlier releases. 
Note that it is possible to enquire the degrees of freedom details for a geometry that is a member of a rigid set; the DCM will return the details with respect to that specific geometry which will not necessarily be the same as the whole set

For certain cases, the DCM may determine that a set has a freedom to rotate, but be unable to identify the location of this rotation. 
In these cases, the set will be able to rotate about a position which depends upon the starting location of the set. 
The current version of the 2D DCM does not return any detailed information about these freedoms. 
The freedom will be counted in the n\_rot argument, but the type DCM\_DOF\_NO\_INFO will be set for the details.

### 16.5.4 degree\_of\_singularity – Compute the degree of singularity for the model

DCM\_dos\_status degree\_of\_singularity(int\* dos)

This function returns dos, the degree of singularity of a model, i.e. 
the number of singular dimensioning configurations present. 
DCM\_dos\_status informs the application on the outcome of the singularity computation.

The possible status codes returned by this function are:

- DCM\_DOS\_SUCCEEDED – the DCM has successfully computed the degree of singularity of the model. 
This is the only return code in which the value of dos should be used.
- DCM\_DOS\_MODEL\_NOT\_SATISFIED – The model is not in a satisfied state and so the degree of singularity cannot be calculated.
- DCM\_DOS\_ABORTED – The computation of the degree of singularity has been aborted (via a customer return from the Frustum).
- DCM\_DOS\_FAILED – Used to indicate that the computation of the degree of singularity failed for an unspecified reason. 
This would indicate a fault in DCM code that could be reported to D-Cubed Components support.
- DCM\_DOS\_UNKNOWN – Not returned from degree\_of\_singularity.

The function degree\_of\_singularity implements a method to perform a global analysis on the DCM model and returns a numerical "degree of singularity". A model which has no singular dimensioning schemes will have a degree of singularity of zero. 
A value greater than one will indicate that the model has one or more regions that are singular. 
DCM is not able, however, to determine whether a higher degree arises because of disjoint singular configurations or where one configuration is multiply singular.

Note that in the current version of DCM, this function is not yet optimized from a performance point of view, therefore it should be used with caution. 
For some models, the computation of the degree of singularity can take significantly more time than a model evaluation. 
It is recommended that use of the degree of singularity functionality is restricted to workflows that are performed infrequently, such as during the investigation or remedying of a model with known constraint issues.

This function will always attempt to recompute the degree of singularity rather than using a stored value. 
The Frustum will be enquired to determine current positions of geometry and values of dimensions, etc. 
Calling this function will effectively reset the DCM so that a subsequent evaluation will be a full evaluate.

See section [2.6 Ambiguous models](2.6._Ambiguous_models.md)

### 16.5.5 list\_singular\_\*\_nodes – Returns array of singular nodes

DCM\_dos\_status list\_singular\_d\_nodes(int\* nd, int array\_size = 0, d\_node\*\* dna = DCM\_NULL, void\*\* ada = DCM\_NULL)

DCM\_dos\_status list\_singular\_r\_nodes(int\* nr, int array\_size = 0, r\_node\*\* rna = DCM\_NULL, void\*\* ara = DCM\_NULL)

DCM\_dos\_status list\_singular\_e\_nodes(int\* ne, int array\_size = 0, e\_node\*\* ena = DCM\_NULL, void\*\* aea = DCM\_NULL)

These three functions return the list of d\_nodes, r\_nodes and e\_nodes, respectively, which are part of singular dimensioning schemes. 
They also return the array of corresponding application objects pointers.

Each of these functions should be called twice, first to determine the number of singular nodes nd (or nr, ne, respectively), and then for DCM to fill in a suitably sized array dna (or dnr, dne, respectively) with the required nodes.

### 16.5.6 transform - Gives current transform of a geometry node

int transform( g\_node\* gn, double mat\[3\]\[3\], double\* internal\_freedom\_offset1 = DCM\_NULL,

     double\* internal\_freedom\_offset2 = DCM\_NULL

      double\* scale1 = DCM\_NULL, double\* scale2 = DCM\_NULL );

Takes a pointer to a DCM geometry node, an empty transformation matrix and pointers to up to four double values to return changes specific to certain geometry types. 
DCM will fill in the values for arguments which have changed only and the other arguments should not be read.

The function returns an integer that can be used to show which of the values returned are significant. 
This integer is the sum of the appropriate values of the following codes, corresponding to the enum DCM\_transform\_status (note the actual integer values are not guaranteed to remain unchanged between versions, always use the enums):

- DCM\_NON\_IDENTITY\_TRANSFORM\_MATRIX = 1
- DCM\_NON\_ZERO\_INTERNAL\_FREEDOM\_OFFSET1  = 2

For circles, ellipses, patterns and offset curves
- DCM\_NON\_ZERO\_INTERNAL\_FREEDOM\_OFFSET2 = 4

For ellipses, array patterns
- DCM\_NON\_UNIT\_SCALE = 8

For scalable, uni-scalable sets
- DCM\_NON\_UNIT\_SCALE2 = 16

For bi-scalable sets
- DCM\_CIRCLE\_INVERTED = 32

Special value for circles
- DCM\_INVALID\_TRANSFORM = 64
- DCM\_INVALID\_NODE = 128
- DCM\_CIRCLE\_JUST\_INVERTED = 256

Note that the values 2 and 4 of the DCM\_transform\_status enum can also be accessed using the macros DCM\_NON\_ZERO\_RADIUS\_OFFSET1 and DCM\_NON\_ZERO\_RADIUS\_OFFSET2 respectively. 
These old names are less meaningful in the cases of internal freedoms of geometries other than circles, but are retained for backwards compatability.

The DCM will include the DCM\_NON\_IDENTITY\_TRANSFORM\_MATRIX code if it determines that the absolute transform transform represents a non-identity transformation, based on an internal threshold value. 
The threshold value does not depend on the angular and linear resolution values which may be configured through the dimension\_system class constructor.

In the case of a relative transform node, the code DCM\_NON\_IDENTITY\_TRANSFORM\_MATRIX will apply only if the value of the transform has changed during evaluation. 
The absolute value of the relative transform node is however returned in the 3x3 matrix.

Note that DCM\_NON\_ZERO\_INTERNAL\_FREEDOM\_OFFSET1 code will not be included in the summation if internal\_freedom\_offset1 is DCM\_NULL, and DCM\_NON\_ZERO\_INTERNAL\_FREEDOM\_OFFSET2 code will not be included in the summation if internal\_freedom\_offset2 is DCM\_NULL, even if the geometry has changed. 
If the geometry has not been evaluated, or it was not changed in the last evaluation, the function will return zero (except for relative transform nodes, as noted above).

For a circle, an optional pointer to a double will return an offset to apply to the current circle radius. 
The offset is the signed difference between the previous value of the radius and the current value. 
Thus, if the radius was changed from 4.0 to 2.0 the offset would be -2.0.

For an ellipse, two optional pointers to doubles can be given. 
The first is the offset for the major radius and the second is the offset to apply to the minor radius. 
Refer to the section [15.13 DCM transforms](15.13._DCM_transforms.md)

For offset curves, the function is used to indicate the change in offset distance, in the internal\_offset\_freedom\_1 argument. 
Unlike the other functions related to offset curves, which use an absolute value for the distance and side specifier, the offset distance value in transform is always output as a signed value, with positive values used for the right side of an open curve, and the outside of a periodic curve. 
The transform output for offset curves is the change in the distance to the offset root (the generator curve). That may not be the immediate parent curve, in which case, this is not the change in the distance value that should be passed in to future DCM solves via DCM\_offset\_distance.

For a scalable set or a scalable spline (including uni- and bi-scalable), the scaling factor can be enquired in the argument scale1. For a bi-scalable set or spline the scale2 value is also used.

If called after the geometry has been evaluated it will return the transformation matrix which was most recently output through the Frustum for this geometry. 
This function can also be called recursively from the Frustum function DCM\_parametric\_regenerate to get the latest position of a geometry that defines a shape of a parametric.

For a relative transform node, the function will always return the full transform stored for the g\_node at the time, not an incremental change from the previous value (as is the case for all other g\_nodes).

It is possible for an application to ignore the requests to transform the geometry which are output through the Frustum, and to update all geometries at a later stage by using this function.

### 16.5.7 transform\_from\_initial - Enquire transform from initial position

int transform\_from\_initial( g\_node\* gn, double mat\[3\]\[3\],

    double\* internal\_freedom\_offset1 = DCM\_NULL,

    double\* internal\_freedom\_offset2 = DCM\_NULL

    double \* scale1 = DCM\_NULL, double\* scale2 = DCM\_NULL );

This function is similar to the transform function except that it returns the geometry transform from the initial position to the current position, i.e. 
the position if the undo\_evaluation function is called with the argument DCM\_UNDO\_TO\_INITIAL.

For relative transform nodes, the full transform is returned by this function (as for the transform function).

### 16.5.8 value - Returns the value of a variable dimension

double value( v\_node\* vn );

The application passes a pointer to a variable dimension or a simple variable (as returned by add\_v) and the DCM returns the current value of this variable. 
The values of the variables are also output through the Frustum following an evaluation. 
Note that the value of the variable is only valid after an evaluation if its status is G\_WELL\_DEFINED.

The value function can also be called during an evaluation in order to find the current values of variables to use to find the value of the residual in a non-linear equation.

### 16.5.9 help\_point - Gives location of a dimension help point

void help\_point( g\_node\* gn, d\_node\* dn, double loc\[2\]);

Takes a pointer to a geometry node (which must be a circle or an ellipse) and a pointer to a dimension node. 
The dimension must be a type that can have a help point, that is, a distance dimension or a tangent constraint onto the geometry or a coincident constraint between the geometry and a point. 
The location of the help point is returned.

Note that it is possible to request the location of a help point even when one has not been provided by the application, for example if the dimension is a minimum distance dimension. 
This can then be used to change the dimension to a dimension with a help point.

If an application has given a help point to the DCM, information about how it is updated is also passed out through the Frustum.

### 16.5.10 equal\_distance\_help\_point - Location of equal distance help points

void equal\_distance\_help\_point( g\_node\* gnthis, g\_node\* gnother, d\_node\* dn, double loc\[2\] );

Takes pointers to two g\_nodes and a pointer to an equal distance dimension dn. 
The location of the help point on geometry gnthis is returned in loc. 
To obtain the help point position on geometry gnother (if appropriate) the function should be called again with the order of the g\_nodes reversed.

### 16.5.11 help\_parameter - Gives value of a dimension help parameter

double help\_parameter( g\_node\* gn, d\_node\* dn );

Takes a pointer to a geometry node (which must be a parametric) and a pointer to a dimension node to that geometry. 
The value of the help parameter is returned.

Information about how the help parameter is updated is also passed out through the Frustum.

### 16.5.12 equal\_distance\_help\_parameter – Get help parameter for equal distance dimension

DCM\_logical equal\_distance\_help\_parameter(g\_node\* gnthis, g\_node\* gnother,

        d\_node\* dn, double\* t);

Takes pointers to two g\_nodes and a pointer to an equal distance dimension dn. 
The value of the help parameter on geometry gnthis is returned in t. 
To obtain the help parameter on geometry gnother (if appropriate) the function should be called again with the order of the g\_nodes reversed.

The function returns TRUE if DCM has set the parameter t and FALSE if this is not set (e.g. 
if the input constraint has no help parameter).

### 16.5.13 help\_parameters - Gives values of a dimension help parameter

DCM\_logical help\_parameters( d\_node\* dn, double t\[2\] );

Takes a pointer to a dimension node which is a single geometry constraint. 
The values of the two help parameters required for the constraint are returned in array t.

Information about how the help parameters are updated is also passed out through the Frustum.

### 16.5.14 query\_offset\_distance – Enquire distance to generating curve of offset

double query\_offset\_distance( g\_node\* gn, DCM\_offset\_side\* os);

Takes a pointer to a geometry node which is an offset curve geometry (i.e. 
type DCM\_offset\_curve). The current value of the offset distance between the curve and its offset root geometry (which will be a parametric, spline or ellipse) is returned from the function as a positive double. 
The sign of the offset distance is return in os, which will be one of two pairs. 
For an ellipse, the return will be either:

- DCM\_OFFSET\_INSIDE
- DCM\_OFFSET\_OUTSIDE

For any other parametric geometry, it will be one of:

- DCM\_OFFSET\_LEFT
- DCM\_OFFSET\_RIGHT

Note that the distance value in this function is always expressed with relation to the offset root curve, as that is the value required in the evaluator function of the curve. 
So for an offset of an offset, the value is not the same as that provided by the DCM\_offset\_distance input, or output in the DCM\_update\_offset\_data functions, which both give the value relative to the offset parent.

If an offset distance is updated to a new value inside DCM during a solve the value is also passed out through the Frustum via the function DCM\_update\_offset\_distance.

The query\_offset\_distance function may be called from DCM\_parametric\_regenerate since it may be required if the offset curve is used as a dependee geometry for another parametric.

Also, the transform function can be called, which outputs any change in the offset distance to the offset root via the DCM\_NON\_ZERO\_INTERNAL\_FREEDOM\_OFFSET1 bit, and the internal\_freedom\_offset1 argument. 
That is, the transform function shows when there is a change in the value returned by query\_offset\_distance, not a change the value from DCM\_update\_offset\_distance.

### 16.5.15 query\_copy\_transform – Enquire measured copy transform

int query\_copy\_transform(g\_node\* gn, double mat\[3\]\[3\]);

Takes a pointer to a geometry node which is a copy curve geometry. 
The current measured transform between the curve and its base geometry (which will be a parametric, spline or offset curve) is returned from the function in mat.

This function returns an integer which is the sum of flags defined within the enum DCM\_transform\_status. 
The following values from that enum may be used for a copy transform:

- DCM\_NON\_IDENTITY\_TRANSFORM\_MATRIX – This value indicates that the copy curve is not identical to the original curve.
- DCM\_INVALID\_TRANSFORM – This value is set if the transform is non-rigid. 
This value will only be set if the initial copy transform provided via the Frustum is invalid: The DCM will not generate an invalid transform internally (even if the model cannot be solved).
- DCM\_INVALID\_NODE – This value is set if the g\_node gn is not a copy g\_node.

If a copy curve is updated the transform is also passed out through the Frustum via the function DCM\_update\_copy\_transform.

### 16.5.16 constraint\_balance - Output overall degrees of freedom count

DCM\_constraint\_balance\_result constraint\_balance( int\* d\_of\_f, int\* constraints, int\* rigid\_body );

Returns three integers:

- d\_of\_f \- The total number of degrees of freedom of the free geometries (i.e., not fixed or frozen).
- constraints \- The number of degrees of freedom removed by the dimensions.

- rigid\_body \- The number of rigid body degrees of freedom remaining in the model.

If the first two numbers are equal and the last is zero then there are sufficient dimensions to completely define the model. 
If the first is equal to the second plus the third then the model can be completely defined apart from rigid body motions. 
See section [2.3 Degrees of freedom](2.3._Degrees_of_freedom.md)

The behaviour of constraint\_balance depends on whether the DCM is in an evaluated state. 
For an evaluated model, DCM will have stored a detailed constraint balance analysis which is used to return the values for this function. 
If the model is not evaluated, then constraint balance will calculate the values. 
This computation will typically be much faster than a full evaluation, but does involve significant work. 
The constraint balance values in this case can differ from those when a model has been fully evaluated, since certain redundancies may not be identified. 
Typically, calling constraint balance on an under-defined model may over-report the numbers of constraints.

The number of rigid body degrees of freedom can be 0, 1, 2 or 3. It includes corrections for the presence of fixed and frozen geometry and for rotational or translational symmetries in the model.

The function returns the following:

- DCM\_CONSBAL\_SUCCEEDED – The function completed successfully.
- DCM\_CONSBAL\_ABORTED – The function was interrupted via the [DCM\_abort\_dcm](17.12._Miscellaneous_functions.md)
- DCM\_CONSBAL\_FAILED\_PGM – This code will only be returned when using the PGM component. 
It indicates that the application has given an invalid model to PGM.

Note that this function only counts the total number of degrees of freedom and constraints. 
A model may appear to be well-defined but may be partly over-defined and partly under-defined. 
A model in a singular position may be unable to move even though constraint balance indicates it is under-defined. 
Note also that inequalities do not affect the values returned by this function.

Finally, constraint\_balance should not be called as during a series of calls to dynamic\_evaluate as part of a drag loop, as it effectively causes a reset in the DCM. 
Thus the state of the model will change after each enquiry such that the drag transforms are modified. 
Since the constraint balance should not change with dragged geometry positions, this limitation is not significant.

### 16.5.17 last\_evaluation\_type - Return DCM evaluation type information

DCM\_evaluation\_type last\_evaluation\_type();

This function can be used to find the evaluation state for the DCM. 
It will returns information about how the results of the most recent call to an evaluation function (see section [16.8 Model evaluation](16.8._Model_evaluation.md)

- DCM\_FULL\_EVAL \- The model has been evaluated and the most recent evaluation was a full evaluation of the whole model.
- DCM\_PARTIALLY\_INCREMENTAL\_EVAL \- Some of model was evaluated incrementally.
- DCM\_FULLY\_INCREMENTAL\_EVAL \- All of the model was evaluated incrementally.
- DCM\_EVAL\_ABORTED \- The last evaluation was aborted by the application.
- DCM\_NOT\_EVAL \- The model has not been evaluated.

### 16.5.18 last\_evaluation\_type - Return node evaluation type information

DCM\_evaluation\_type last\_evaluation\_type( g\_node\* gn);

This function is called with a pointer to a g\_node. 
Similar functions exist for all other node types (d\_nodes, r\_nodes, e\_nodes, v\_nodes and p\_nodes). The function returns how the node was evaluated by the most recent call to an evaluation function.

These functions can return the same values as the previous function except that they do not return DCM\_PARTIALLY\_INCREMENTAL\_EVAL.

### 16.5.19 next\_re\_evaluate\_type – Query the outcome of the next solve

DCM\_evaluation\_type next\_re\_evaluate\_type(int ng = 0, g\_node\*\* gn = DCM\_NULL,

DCM\_solving\_mode mode = DCM\_STANDARD\_SOLVE);

Incremental evaluation is possible provided that dimensions have not been added or erased since the last full evaluation. 
If changes have been made (for instance by calls to add\_d or erase) then a full evaluation will be done when re\_evaluate is used. 
If any of the arguments to re\_evaluate change, this will also result in a full evaluation.

This function returns what the outcome of a call to re\_evaluate() would be, if it was called with the specified parameters. 
It will return one of the following values:

- DCM\_FULL\_EVAL\- A full evaluation will for the whole model.
- DCM\_PARTIALLY\_INCREMENTAL\_EVAL \- Some of model will be evaluated incrementally.
- DCM\_FULLY\_INCREMENTAL\_EVAL \- All of the model will be evaluated incrementally.

### 16.5.20 measured\_value – Return measured value of a dimension

DCM\_measured\_status measured\_value(d\_node\* dn,double\* value);

The application calls the function with dn, a pointer to a DCM\_ARC\_LENGTH (or DCM\_CURVE\_LENGTH) d\_node. 
When the call is made, DCM will call the Frustum in order to determine the current position and shape of any geometry involved in the constraint. 
Therefore the value returned will be that of the current application geometry.

The DCM will return one of:

- DCM\_MEASURED\_STATUS\_UNSUPPORTED\_TYPE

returned if the d\_node is not of type DCM\_ARC\_LENGTH or DCM\_CURVE\_LENGTH. 
The value property is not set.
- DCM\_MEASURED\_STATUS\_CANNOT\_MEASURE

returned if no measured value can be obtained. 
E.g. 
curve length parameters are outside the range of the parametric curve. 
Currently this status will not be returned for an arc length.
- DCM\_MEASURED\_STATUS\_MEASURED

The DCM has successfully measured and returned the value of the dimension.

For a curve length dimension the value returned will be the measured distance along the curve from the first help parameter to the second (a signed value). This may be different from the value of the dimension if the model has not been solved.

Note that the measured\_value function can produce a measured value for an arc length dimension even when the constraints that define the arc are not in a satisfied position. 
For example, if the points are not coincident to the circle to within resolutions, then DCM will find the nearest positions on the circle for each point.This function cannot be called recursively (i.e., during a Frustum call). Calling this function does not cause a full evaluation.

### 16.5.21 pattern\_value – Return latest solved 1D pattern value

double pattern\_value(g\_node\* gn);

Takes a pointer to a 1D pattern reference node. 
The returned double is the absolute signed value of the distance (linear pattern) or angle (rotational pattern, radians).

### 16.5.22 pattern\_value\_2d – Return latest solved 2D pattern values

void pattern\_2d\_value(g\_node\* gn, double\* v1, double\* v2);

Takes a pointer to a 2D pattern reference node. 
The doubles v1 and v2 are the absolute signed value of the distances in the two defining directions, with the order corresponding to that used in the original call to add\_pattern\_2d.

### 16.5.23 enquire\_winding\_angle – Enquire measured winding angle

DCM\_logical enquire\_winding\_angle(d\_node\* dn, double\* value);

Takes a pointer to a d\_node, dn, identifying the arc length dimension. 
The application passes a pointer to a double, value, which will be set to the returned value if possible. 
DCM will return DCM\_TRUE from the function if value has been set and DCM\_FALSE if value has not been set (e.g. 
if the pointer dn is NULL).

### 16.5.24 model\_satisfied – Return if the constraints in a model are solved

DCM\_satisfied\_status model\_satisfied(DCM\_logical check\_between\_rigid,

double res\_linear,

double size);

The model\_satisfied enquiry allows the application to identify any constraints in the model which are not satisfied by the current positions of their associated geometries. 
This may be used by the application for display or diagnostic purposes. 
This can be especially useful to customers just starting with DCM, as they can test if they are adding the expected constraints.

For example, in the Analyse user interface, points may be added in 2D space using the cursor. 
Users often add points at arbitrary locations before constraints are added. 
Imagine that two points are added in this manner such that the measured distance between these points is 9.7 units. 
If the user wishes to control the distance between these points, they might add a distance dimension with a value of 10.0 units.

Before a call to the DCM evaluate function, this constraint would not be satisfied, since the measure value (9.7 units) is not equal to the dimension value (10.0 units). After the evaluation, one of the two points will be moved to a position such that the measured distance between the points is now 10.0 units (to within resolutions). The constraint will therefore be satisfied.

The application must specify the following options:

- check\_between\_rigid – A logical value that indicates whether DCM should check constraints between geometries that are fixed, or within the same rigid set. 
These constraints will not be solved by DCM, but this function can check whether they have satisfied values if requested.
- res\_linear, size \- Specify the linear resolution and size to which the constraints should be checked. 
These are equivalent to the values that are set when constructing the DCM dimension system for solving. 
The application may choose to use tighter or looser tolerances when checking compared to those that will be used when DCM solves the model.



The resolutions supplied must satisfy 10-20 < res\_linear < 1020 and 10-10 < size < 1010. Additionally, both the linear resolution and the derived angular resolution (linear resolution / size) must be greater than the machine accuracy, which is typically around 10-14 but can vary depending on the operating system on which DCM is running. 
If these conditions are not satisfied then DCM\_SS\_INVALID\_RESOLUTION will be returned and no checking will take place.

The returned status will be that of the least satisfied constraint or equation in the model. 
The types in DCM\_satisfied\_status are listed in ascending order of satisfaction. 
These are as follows:

- DCM\_SS\_INVALID\_RESOLUTION \- Supplied resolution/size is not valid.
- DCM\_SS\_NOT\_SATISFIED \- Not satisfied to supplied resolution/size.
- DCM\_SS\_UNSUPPORTED\_TYPE – Called for a model that contains constraints that are not currently supported.
- DCM\_SS\_SATISFIED \- Satisfied to supplied resolution/size.
- DCM\_SS\_HELP\_POINTS\_NOT\_SATISFIED – The model/constraint is in a satisfied position, but associated help points are not. 
This is explained in more detail in [16.5.24.1 Help points in satisfied models](#_Ref336439731).
- DCM\_SS\_NOT\_CHECKED \- Returned only during Frustum calls to mark nodes that can be checked but have been skipped. 
Currently this will be only when checking of constraints between rigid geometries is disabled (check\_between\_rigid set to false).

The satisfied statuses of individual constraints can be enquired using the satisfied function.

If the model is not in a solved state, the application can makes any edits to the model before performing an evaluation and obtain accurate results from model\_satisfied, because DCM will perform a full update to the model definition via the Frustum during the call.

On the contrary, if the model is already in a solved state, a call to model\_satisfied before the next evaluation will ignore any edits made to the properties listed in [2.5.3.3 Incremental evaluation after changing the model outside DCM](2.5._Evaluating_the_model.md)
A subsequent incremental evaluation will obviously not take those edits into account.

Applications will therefore need to consider the circumstances when calling model\_satisfied. 
If it is known that the next evaluation will be a full one, it would be safest to call DCM reset before calling model\_satisfied.

A model which is not satisfied may not exhibit any visible movement following an evaluation. 
For example, a constraint may be unsatisfied because of an alignment, and this may not cause any visible change in the model upon evaluation. 
Similarly, because the resolutions to which DCM solves are generally very small, a small change in position may be sufficient to satisfy the constraints.

Conversely an individual constraint may be satisfied, but the associated geometries may still have to move after an evaluation due to other unsatisfied constraints acting upon them. 
In particular, there are cases where all constraints and dimensions are satisfied for the specific values, but with the initial geometry positions the dimension values cannot be varied independently. 
DCM may still solve these models by making large rotations in geometry, whilst maintaining all the constraints on the model, so that the dimensions can now be solved over a range of values.

#### 16.5.24.1 Help points in satisfied models

With constraints involving help points, during model\_satisfied, DCM will always use the positions of those help points to interpret the constraint, internally working out the effective position. 
Therefore, model\_satisfied and satisfied will return DCM\_SS\_NOT\_SATISFIED for a model if the effective position of a constraint indicates that the solution would be in a different chirality, regardless of the option to check satisfied status. 
In [Figure 78: Unsatisfied tangent](#_Ref71627774), for example, the help point is shows as the small circle top left of the circle, which is tangent to the line. 
This tangent constraint is not satisfied because the help point provided is on the far side of the circle, but the exact position of the help point does not matter.

![Shape, circle  Description automatically generated](../Resources/Images/2ddcm_manual/Enquiry functions.png)

Figure 78: Unsatisfied tangent

In those cases where the help point is on the near side of the circle, DCM considers the tangency satisfied but it can return information on whether the application is providing an exact help point or an approximate one. 
Applications can choose how help points are interpreted when querying if a model is satisfied or not using the option DCM\_OPKEY\_MODEL\_SATISFIED\_CHECK\_HELP\_POINTS which can be set to ON or OFF. 
This option is ON by default.

If the option is off, then models which are geometrically satisfied will return DCM\_SS\_SATISFIED from model\_satisfied even if help points provided by the application are not at the exact position where DCM measures the solved constraint.

If the option is on, then models which are geometrically satisfied, but for which the help points are provided in approximate positions, will return DCM\_SS\_HELP\_POINTS\_NOT\_SATISFIED following a call to model\_satisfied.

The following images display a circle tangent to a line, with a help point used in both cases. 
In [Figure 79: Satisfied help point](#_Ref335816409), the help point is in an exact (satisfied) position. 
In [Figure 80: Unsatisfied help point](#_Ref335816447), the help point is only approximately positioned, so not in a satisfied position. 
In both cases, however, the effect of the help point on the solve is exactly the same.

![](../Resources/Images/2ddcm_manual/Enquiry functions_1.png)

Figure 79: Satisfied help point

In [Figure 79: Satisfied help point](#_Ref335816409), where the help point is satisfied, the constraint will be marked as DCM\_SS\_SATISFIED irrespective of if the option DCM\_OPKEY\_MODEL\_SATISFIED\_CHECK\_HELP\_POINTS is ON or OFF.

![](../Resources/Images/2ddcm_manual/Enquiry functions_2.png)

Figure 80: Unsatisfied help point

In [Figure 80: Unsatisfied help point](#_Ref335816447), where the help point is only approximate, setting the option DCM\_OPKEY\_MODEL\_SATISFIED\_CHECK\_HELP\_POINTS to OFF will result in the constraint being marked as DCM\_SS\_SATISFIED. 
Conversely, setting the option DCM\_OPKEY\_MODEL\_SATISFIED\_CHECK\_HELP\_POINTS to ON will result in a status is DCM\_SS\_HELP\_POINTS\_NOT\_SATISFIED.

### 16.5.25 satisfied – Return if a constraint is in a solved state

DCM\_satisfied\_status satisfied(d\_node\* dn, double res\_linear, double size);

DCM\_satisfied\_status satisfied(e\_node\* en, double res\_linear, double size);

DCM\_satisfied\_status satisfied(r\_node\* rn, double res\_linear, double size);

Returns if an individual constraint is satisfied, as in model\_satisfied. 
The rules to obtain accurate results with calls to model\_satisfied apply to calls to satisfied.

If the model is not in a solved state, the results will be accurate for any edit made to the constraints before the next evaluation. 
If the model is in a solved state, the function will not take into account edits to the properties listed in [2.5.3.3 Incremental evaluation after changing the model outside DCM](2.5._Evaluating_the_model.md)

While equations may be queried, the satisfied status of variables cannot be queried.

