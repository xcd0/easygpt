## 2.5 Evaluating the model

This section explains some important concepts related to the way that the DCM solves, or evaluates, a model. 
DCM provides a number of evaluate functions which are tailored to certain uses but which all follow the same basic principles.

Additional DCM functions are provided for analysis and automatic generation of constraints. 
Analysis functions, which do not involve fully solving the constraints include constraint balance, model satisfied and degree of singularity. 
Automatic functions include autoconstrain and autodimension. 
These are detailed in separate sections of the manual.

### 2.5.1 General

During an evaluation the DCM will attempt to do the following:

- It will ensure that dimensions and constraints for a consistent model with the ability to change any non-rigid dimensions and equation values.
- It will solve any equations and find the values of any variables.
- It will determine transformations to apply to the geometry so that all currently defined dimensions are satisfied.
- It will set status codes on each entity depending upon the success or otherwise of the evaluation.

All of these steps are performed simultaneously for the entire model.

Only a single solution will be found by the DCM. 
Which solution is found depends upon the initial configuration of the geometries, dimensions and equations, any pending requests to change the chirality. 
It also depends on options which are passed to the DCM. 
Many of the options are provided to affect which solution is found for under-defined geometry, and these are described below. 
The solved position of well-defined geometry is unaffected by these options.

The application can also request that the DCM should apply specified transforms to geometries as part of the evaluation procedure. 
See sections [2.5.4 Dragging geometry](#_Ref410529785) and [5.3 Moving geometry and preserving chirality](5.3._Moving_geometry_and_preserving_chirality.md)

The following sections describe further details of how the geometry is evaluated. 
Section [16.8 Model evaluation](16.8._Model_evaluation.md)

### 2.5.2 Resolution and accuracy

Resolution refers to the numerical values that the DCM uses when it makes comparisons. 
Typically, these comparisons are used to detect special cases that should be treated in a particular way. 
The DCM uses two resolution values which may be set by the application when constructing the DCM instance.

One of these is a dimensionless value and is used to compare angular quantities. 
It is referred to as the angular resolution. 
The other has dimensions of length and is used to compare distances. 
It is referred to as the linear resolution. 
The appropriate value is used whenever a comparison is necessary.

For example, the DCM may need to test if two fixed lines are parallel. 
It will use the angular resolution for this. 
Similarly, it may need to find if a dimension value is equal to the sum of two other dimension values. 
It will use the linear resolution for this.

![Fig1_resolution.bmp](../Resources/Images/2ddcm_manual/Evaluating the model.png)

Figure 2: Uses of resolution

A third value can be defined that relates together the linear and angular resolutions. 
This is the size and is found by dividing the linear resolution by the angular resolution. 
Geometrically, if two lines are coincident at one endpoint, and have an angle of the angular resolution between them, they will separate by the linear resolution over a length of size.

In principle, if a model has inaccuracies which are similar to the resolutions, it can only be handled consistently if it is smaller than size.

Accuracy refers to how close the solution found by the DCM matches the input data. 
For solutions that are found algebraically, the accuracy of the solution only depends upon the accuracy of the computer and the accuracy of the input data. 
Typically, the accuracy of models that are solved algebraically is close to the accuracy of the computer.

When the DCM uses an iterative solution (such as when solving a dimension to a parametric) it will iterate to a solution that is more accurate than the current resolution values. 
Normally, a much higher accuracy is achieved.

It is guaranteed that any solution found by the DCM will be at least as accurate as the current resolution values.

The DCM works with unitless numbers and it is up to the application to choose what units to use. 
Hence, an application can decide if a unit in the DCM corresponds to a millimetre, a metre or a kilometre. 
When choosing the resolution and the units, it is important that the limitations imposed by the accuracy of the computer and the consistency of the data are considered. 
The following guidelines should avoid any problems:

- Any inaccuracies in the data passed to the DCM should be significantly smaller than the resolution. 
It is suggested that a factor of ten is used. 
For example, if two fixed geometries are intended to be coincident, they should be coincident to within one tenth of the resolution.
- The size of detail in the model should be significantly larger than the resolutions. 
Again, a factor of ten is suggested. 
For example, if two fixed geometries are intended to be distinct, the distance between them should be greater than ten times the resolution.
- All the geometry in the model should fit into a box of length size. 
It is not necessary that the box (and hence the model) is centred about the origin.



However if the geometry is long way (compared to size) from the origin then the accuracy of all calculations will be reduced. 
This is because only a certain number of decimal places are available.



Currently the DCM has no knowledge of number ranges used for geometry and hence it is recommended that the models should not be a long way from the origin.

In the majority of cases no problems will be found even if the above guidelines are not followed. 
However, a complex model may imply a build-up of the inaccuracies such that no consistent solution can be found.

Note that the DCM may move geometry even if all dimensions are satisfied to within the resolutions if this will give a more accurate solution.

### 2.5.3 Incremental evaluation

When the DCM evaluates a model it can use either a full or an incremental method. 
As mentioned in chapter [1\. Introduction to the DCM](1._Introduction_to_the_DCM.md)
The first step in a full evaluation is to analyse the chirality of the existing geometry and to determine a method of solving the model. 
In the second stage the DCM will calculate the transformations to apply to the geometry to satisfy the dimensions with the appropriate chirality. 
This process has the advantage that in some situations the geometry can be re-evaluated using just the second stage of the algorithm (which saves time). This is referred to as incremental evaluation.

In order for the evaluation to be performed incrementally, it is necessary that no dimensions are added or deleted. 
If they are, the DCM will detect that it is not possible to evaluate incrementally, and a full evaluation will be performed instead.

Before an incremental evaluation the application is permitted to change the values of dimensions, or the coefficients of linear equations. 
This is particularly useful when the DCM is required to find solutions where one or more values are changed repeatedly. 
Examples of this are generating families of parts and design animation.

It is important to consider that DCM obtains its new values for incremental evaluations via the Frustum interface. 
As such in many cases, no update enquires are made for values and properties than may not be changed during an incremental solve. 
So even though an application may have changed its own data, if DCM is solving incrementally, it may never see that change. 
Properties that are not permitted to change in an incremental evaluation are listed in section [2.5.3.3 Incremental evaluation after changing the model outside DCM](#_Ref26282836).

Note that the chirality of the solution will be preserved when a model is evaluated incrementally, even if the geometry has been moved to a new location. 
This has two important consequences. 
Firstly, if an application wishes to move the geometry in order to change the chirality of the solution it should use a full evaluation. 
Secondly, it is possible for an application to move geometry, and then to find a solution in the original chirality.

If fixed geometry is moved prior to an incremental evaluation there is a possibility that constraints implied by the DCM between fixed geometries will be violated. 
See section [6.2 Implied constraints](6.2._Implied_constraints.md)
Consequently, the incremental evaluation may fail to find a valid solution.

Although an application is not prevented from moving geometry (including fixed geometry) before an incremental evaluation it is strongly recommended that this is not done as it may lead to unpredictable results. 
See section [5.3 Moving geometry and preserving chirality](5.3._Moving_geometry_and_preserving_chirality.md)

Incremental evaluation is also possible after an application has asked that the DCM should change the chirality in order to find a different solution. 
See the earlier section [2.4 Chirality](2.4._Chirality.md)

It is also possible to use incremental evaluation after calling DCM functions that do not change the internal data structure. 
Typically, these are functions that only enquire data from the DCM such as status, debug\_xmit and the entity association functions described in section [16.13 Model enquiry functions](16.13._Model_enquiry_functions.md)

DCM functions: [re\_evaluate](16.8._Model_evaluation.md)

#### 2.5.3.1 Model partitioning

If a model contains two or more groups of geometry that are completely disconnected (i.e. 
do not have any shared dimensions) then changes to one group will not affect the others. 
DCM automatically identifies disconnected regions within models and maintains these in internal structures called partitions. 
Each partition can be solved independently of the others. 
Changes made to geometry or dimensions within a single partition need not affect the state of other partitions.

For example, adding a dimension between two geometries will cause the DCM to reset its state and invalidate any stored solution that would be used for incremental solving. 
However, when the model is divided into partitions, then the addition of a dimension will only reset the partition of the geometry being constrained.

When the function re\_evaluate is called, it is necessary for the DCM to do a full evaluation on the partition that was reset but all the other partitions can be evaluated incrementally.

DCM automatically maintains the partition structure during operations such as adding or deleting a node; No specific support is required from the application. 
For example, if a dimension is added between geometries in two different partitions, DCM will need to merge these into a single partition. 
This automatic partitioning gives significant performance improvements on some models, particularly when DCM is used in a persistent manner to perform a series of sequential evaluations.

#### 2.5.3.2 Solving specific partitions

The main DCM solving functions (evaluate, re\_evaluate, dynamic\_evaluate and move\_and\_evaluate) always ensure that a full DCM solution for the whole model has been determined. 
This means that all constraints and equations in the system will have been analysed and given suitable statuses, and the positions and values of all geometry and variables updated and reviewed.

For the incremental functions (re\_evaluate and dynamic\_evaluate) DCM will re-use the majority of work from any previous calls to that function, where they have been made, giving significant performance savings. 
However, if no previous call has been made, DCM will still solve the entire model fully in order to ensure all constraints have been considered.

To provide even better performance, DCM also provides solving functions that are limited to specific partitions: evaluate\_partitions, re\_evaluate\_partitions and dynamic\_evaluate\_partitions. 
These functions will solve only those constraints and dimensions that are relevant to specific geometry specified by the application. 
Any unrelated constraints, dimensions and equations will not be solved, and the unconnected geometry and variables will not have their positions and values determined.

These functions operate on the internal partitions that DCM automatically generates based on the connectivity of constraints in a model. 
The application does not need to know and maintain the structure of these partitions to take advantage of the functionality: The partition specific solving functions allow a simple list of DCM nodes to be specified which must be solved. 
DCM will solve all partitions which are referenced in the list.

DCM has analysed the full structure of the model in generating its partition structure and is therefore able to solve the specified geometry fully whilst safely ignoring any in other partitions. 
The output from partition specific solving is the same as for the main DCM functions: Any nodes in the DCM model that change status or position result in a Frustum call to advise the application. 
Those nodes which are unchanged receive no calls, whether they are included in the partition being solved or not.

The key limitation with partition specific solving is that no analysis is performed on the rest of the model. 
Therefore DCM cannot warn the application about over-defined geometry and it will not solve any constraints that are unsatisfied. 
The geometry and constraints in unsolved partitions will generally retain the status from before the solve, whether that is solved, or unknown, etc.

This functionality is particularly useful for large models which are known to be in a satisfied state, with no over-defined geometry. 
A typical example would be for models which have previously been loaded into DCM and solved by the same revision of a customer’s application. 
When the application data is reloaded and added back to DCM, it may be possible to assume that the DCM solution will be unchanged from the previous session and thus to limit solving to areas of the model that are to be changed.

Note that multiple calls to evaluate\_partitions or re\_evaluate\_partitions can be used to progressively solve the entire DCM model, leaving it in a state equivalent to a single call to the whole-model versions evaluate or re\_evaluate. 
Note also that a partition specific undo function is provided.

DCM functions: [evaluate\_partitions](16.10._Partition_specific_solving.md)

#### 2.5.3.3 Incremental evaluation after changing the model outside DCM

When an incremental evaluation takes place, the DCM will assume certain properties have not changed since the last full evaluation. 
This means that certain Frustum functions will not be called, and the DCM will instead use cached values. 
If the model has changed outside of the DCM in such circumstances, the changes will not be reflected in the DCM model, potentially giving surprising results.

Model definition data can be grouped according to the rules about when it may be changed, which are:

- Never changeable, only set when a node is added. 
Can only be changed by erasing and re-adding a node (forcing a full evaluate).

- Includes connectivity defined by the arguments passed to interface functions (e.g. 
the list of nodes in add\_d).

- Includes properties defined by Frustum functions such as DCM\_g\_identify and DCM\_dimension\_type.

- Only changeable in a full evaluation – these cases will force a full evaluate because they must be changed using interface functions.

- Fixed and locked state on nodes.

- Membership of sets.

- Includes some spline properties (using replace\_spline).

- Only changeable when a full evaluation is being performed – these changes can only be made by calling reset, or by performing some other interface change that forces a full solve. 
Otherwise, the corresponding frustum functions are simply not called.

- Constraint chirality control properties including: whether help points are provided; whether help parameters are provided; alignments, half spaces.

- Solution control choices, including: transform bias, resolve zero diamond choices.

- Rigid dimension values.



Note that prior to version 74, the values of rigid dimensions would be updated from the frustum during an incremental evaluation. 
Potentially those changes could result in invalid solutions, if previous assumptions based on dimension values no longer applied. 
For example, a rigid angle of pi radians may be treated as a parallel constraint. 
If the value is updated during the incremental solve, the value might not be used in computing the solution, or else some other parallel may become unsatisfied instead. 
An option is provided to revert to this behaviour, should applications be relying on it, as detailed in [2.5.3.3.1 Rigid dimensions in incremental evaluations](#_Ref90913467).

- Rigid equation coefficients and constants.

- Fixed geometry positions.



Note that 2D DCM will currently enquire the positions for fixed geometry during an incremental evaluate call and use those positions when computing the positions, but it will not change its method of finding the solution to account for these new positions. 
This can lead to invalid solves.

- Fixed parameter node values.

- Inequality limits.

- Parmetric periodicity.

- Changeable on an incremental evaluation.

- Values of non-rigid dimensions.

- Positions and sizes of free geometry.

- Some spline interpolation conditions.

- Equation constant and coefficients for non-rigid equations.

- Parametric limits.

The following table lists frustum functions that are not called during an incremental evaluation, meaning that their corresponding properties must not be changed before an incremental evaluation. 
If such a property has changed, the application must call reset.

Model property

Function

Notes

Geometry type

[DCM\_g\_identify](Geometry definition functions.md)

Only enquired in add\_g

Circle invertibility

[DCM\_circle\_allow\_inversion](Geometry definition functions.md)

Dimension type

[DCM\_dimension\_type](Basic dimension functions.md)

Only enquired in add\_d

Whether equal distance dimension help point is supplied or not

[DCM\_equal\_distance\_dimension\_point](Basic dimension functions.md)

The help point can be changed, but the DCM\_logical return should not be

Directed distance information

[DCM\_directed\_distance](Basic dimension functions.md)

Alignment

[DCM\_dd\_alignment](Basic dimension functions.md)

Pattern multiplier

[DCM\_pattern\_multiplier](Basic dimension functions.md)

2D pattern multipliers

[DCM\_pattern\_2d\_multipliers](Basic dimension functions.md)

Pattern start value

[DCM\_pattern\_start\_value](Basic dimension functions.md)

2D pattern start value

[DCM\_pattern\_2d\_start\_value](Basic dimension functions.md)

Zero diamond behaviour

[DCM\_resolve\_zero\_diamond](17.12._Miscellaneous_functions.md)

Equal derivative alignment

[DCM\_equal\_derivative\_alignment](Basic dimension functions.md)

Tangent alignment

[DCM\_tangent\_alignment](Basic dimension functions.md)

Alignment

[DCM\_dimension\_alignment](Basic dimension functions.md)

Symmetry alignment

[DCM\_symmetry\_alignment](Basic dimension functions.md)

Normal alignment

[DCM\_normal\_alignment](Basic dimension functions.md)

Transform bias

[DCM\_g\_transform\_bias](17.12._Miscellaneous_functions.md)

Dimension half space

[DCM\_dimension\_half\_space](Basic dimension functions.md)

Equal distance half space

[DCM\_equal\_distance\_half\_space](Basic dimension functions.md)

Rigidity

[DCM\_dimension\_rigid](Basic dimension functions.md)

Scaling centre

Periodicity of parametric

[DCM\_parametric\_limits](Frustum functions for evaluated.md)

The arguments are the parametric limits, which can be changed.

Period of parametric

[DCM\_parametric\_period](Frustum functions for evaluated.md)

Parametric extension data

[DCM\_parametric\_extension\_data](Frustum functions for evaluated_1.md)

Parametric extension data

[DCM\_parametric\_extension\_parameters](Frustum functions for evaluated_1.md)

Whether equal distance help parameter is used

[DCM\_equal\_distance\_dimension\_parameter](Frustum functions for evaluated_1.md)

The return value should not be changed, but the help parameter itself can be

Whether a help parameter for an ellipse is used

[DCM\_ellipse\_dimension\_parameter](Basic dimension functions.md)

The return value should not be changed, but the help parameter itself can be

Equation type

[DCM\_equation\_type](Frustum functions for variables.md)

Only called during add\_e

Value of the constant in a linear equation

[DCM\_equation\_constant\_value](Frustum functions for variables.md)

If the equation is rigid, this can be changed

Coefficient value in a linear equation

[DCM\_equation\_coefficient\_value](Frustum functions for variables.md)

If the equation is rigid, this can be changed

Inequality minimum

[DCM\_inequality\_minimum](Frustum functions for variables.md)

Inequality maximum

[DCM\_inequality\_maximum](Frustum functions for variables.md)

Table 1: List of model properties and corresponding frustum functions that cannot be changed before an incremental evaluation is performed

##### 2.5.3.3.1 Rigid dimensions in incremental evaluations

The Frustum function DCM\_dimension\_valueis called during an incremental evaluation to update the value of normal dimensions.

This function is not called for rigid dimensions in DCM version 74 and later. 
If an application updates the value of a rigid dimension and performs an incremental evaluation, such change will be ignored by DCM. 
The dimensions this applies to are all the ones that can be made rigid:

- distance
- directed distance
- angle
- circle radius
- ellipse major radius
- ellipse minor radius
- arc length
- curve length
- dimensioned conic rho value
- 1D and 2D pattern value

In order to change the value of a rigid dimension during an incremental evaluation, the application should either call reset or set the value DCM\_OPVAL\_ONfor the option DCM\_OPKEY\_INCREMENTAL\_RIGID\_DIMENSION\_UPDATE.

### 2.5.4 Dragging geometry

When a design has been sketched, with perhaps some logical constraints defined but few (if any) dimension values specified, it is common to wish to move sections of the design relative to the rest of it. 
The DCM supports this by providing functions that allow the application to specify transformations to apply to geometry while it is being solved. 
These functions allow sophisticated changes to be made to under-constrained designs.

The term used for this type of operation is dragging. 
Dragging free geometry will only have an effect on a design that is partly under-constrained. 
The following considerations are relevant to the way that dragging is implemented:

- Any number and all types of geometries in a design can be transformed, including fixed and frozen geometries. 
Note however that dragging a large number of geometries may be slow.
- The transformations (which need not be the same for each geometry) can be any combination of translations, rotations and (for circles and ellipses) changes in radius. 
In addition, an interface is provided to allow updates to the shape of parametric curves.
- During dragging, the DCM will transform the specified geometries by the given transformation (if possible). Other geometries from the design will also be transformed such that no defined dimensions or constraints are violated.
- It is possible for an application to use any of the four solving modes described in section [2.5.6 Solution control for under-constrained geometry](#_Ref498157745) when dragging. 
The default (and recommended) mode is the minimum move mode.
- In some cases the specified geometries will not have sufficient degrees of freedom available to accept the given transformation. 
An application can inform the DCM what behaviour it requires in these cases and the DCM will return if this has been achieved. 
See the explanation of the function dynamic\_evaluate in chapter [16\. The DCM Interface](16._The_DCM_Interface.md)
- Typically, dragging is an interactive, multi-stage operation and the model is updated in a number of small steps. 
At each stage the application has the option of using the current position, reverting to the previous position or reverting to the original position.
- For certain applications, the partition specific version of the function, dynamic\_evaluate\_partitions may be appropriate. 
This will limit the DCM solving to only geometry related to the drag geometry.

DCM functions: [dynamic\_evaluate](16.9._Dragging_geometry.md)

### 2.5.5 Algebraic and non-algebraic solving

Most practical dimensioning schemes involving dimensions between points, lines and circles can be constructed using standard drawing board techniques. 
All such schemes can be solved by the DCM without using numerical techniques, and are referred to as algebraic. 
Dimensioning schemes that require numerical techniques are referred to as non-algebraic. 
These cannot be constructed using standard drawing board techniques.

Whenever possible the DCM will use algebraic solving methods in preference to non-algebraic or numerical methods. 
There are several reasons why algebraic solving methods are superior to numerical techniques:

- When solving algebraically, the chirality of the design will always be preserved, no matter how large the dimension changes are. 
A numerical technique may cause the solution to jump and lead to hysteresis. 
This can nearly always be overcome by making the changes in smaller increments.
- Algebraic methods are inherently more accurate than numerical methods.
- Algebraic methods are generally much faster than numerical methods.

A simple example of a design that includes points and lines but which cannot be solved with algebraic methods is:

![fig3_numerical.bmp](../Resources/Images/2ddcm_manual/Evaluating the model_1.png)

Figure 3: An example that cannot be solved algebraically

The DCM is generally used in its default mode which uses numerical methods as a backup method for models that it determines cannot be solved algebraically. 
However, it is possible to modify this behaviour so that the secondary numerical processing is either prevented entirely or used only partially. 
This functionality can be of use in certain situations when performance is of primary concern.

One recommended situation where applications can choose to change the default solving methods is during auto-dimensioning of models. 
In the auto-dimensioning process, geometry with a large number of remaining freedoms will be fully dimensioned by application new dimensions automatically, whilst ensuring that the model does not become over-defined. 
Typically, there can be a very large number of possible dimensions available to remove the freedoms on even a single geometry in a sketch. 
The dimensions chosen can have a large effect on the performance and solving behaviour.

Therefore, in some situations, customers will choose to disable non-algebraic solving for the duration of an auto-dimension call. 
This will ensure that DCM does not choose dimension schemes that would require numerical solving methods. 
Even if those dimensions are possible given the input options and even if they are given priority using autodimension weights, DCM will not apply them since they would cause the model to become non-algebraic. 
At the end of the autodimension call an application would usually revert to the default behaviour (i.e. 
turn non-algebraic solving back on) so that further user-specified dimensions that did require numerical methods would work.

This approach works well in a model without initial dimensions (that is, with just DCM logical constraints present removing the initial freedoms). This method cannot be used if the model already has non-algebraic regions, however, which may occur in a model that already has some dimensions.

Non-algebraic solving will be enabled automatically if the application chooses to take advantage of the singular configuration diagnostic in autodimension, possible when using the autodimension interface that was introduced in version 68.0. It should be noted that using the functionality to avoid singular dimensioning schemes will result in an additional performance penalty compared to even regular DCM solving with non-algebraic solving enabled.

DCM function: [set\_option](16.2._Configure_global_DCM_behaviour.md)

### 2.5.6 Solution control for under-constrained geometry

The DCM is designed to allow users to work with under-constrained geometry. 
It is very natural first to sketch out the shape of a design and then to refine it by specifying logical constraints and dimensions. 
Because an under-constrained geometry has some remaining degrees of freedom there is a range of possible solutions. 
The DCM provides three methods to influence the solving of under-constrained geometry: solving modes, prioritised geometry and transform bias.

Each solving mode treats under-constrained geometry in a different way such that the application may select the most appropriate for the task. 
For example, the weighted standard solving mode is the default and recommended mode for the move\_and\_evaluate function. 
It gives priority to the changes in geometry position being made by the application.

Prioritised geometry is used in conjunction with the solving mode to control in more detail the way under-constrained geometry is solved. 
In addition to specifying the solving mode, the application may also designate an array of geometry that will be given a higher priority when solving. 
The geometry array always gives the highest priority to the first element in the array. 
Depending on the solving mode, array elements will either be more likely to move or more likely to remain in the same position. 
The effect is described for each solving mode below.

The transform bias functionality allows an application to indicate which geometry it would prefer to change or not to change. 
This bias information can be quantitative. 
The DCM will override the bias information only if necessary to find a solution. 
In general, using transform bias will give a greater degree of control to the application over which geometries will move.

Note that if the DCM is asked to solve any configuration where all of the dimensions are already satisfied it will not make any changes. 
The options described below will only have any effect if there are unsatisfied dimensions.

Each of the five solving modes can be used with each of the evaluate functions (evaluate, re-evaluate, dynamic\_evaluate and move\_and\_evaluate). However, it is recommended that the default solving mode for each function is used for most cases. 
The solving modes are:

Standard

Moves under-constrained geometry rigidly.

Default mode for evaluate and re-evaluate.

Weighted standard

Moves geometry in order to position selected geometry.

Default mode for move\_and\_evaluate.

Localised

Aims to move only geometry near to unsatisfied constraints, changing dimensions and dragged geometry.

Recommended for new users with dynamic\_evaluate and for making local changes with evaluate/re\_evaluate.

Note: works best when making constant-value dimensions rigid during the lifetime of the solving sequence.

Minimum move

Moves smallest number of geometries.

Default mode for dragging with dynamic\_evaluate.

Relaxation

Solves using relaxation methods.

Will move many geometries different amounts.

Used to solve models that are far from solution.

Usually the slowest solving mode.

Recommended if standard solving cannot find a solution.

#### 2.5.6.1 Standard solving mode

In the standard solving mode the DCM will propagate geometry transformations through the model as it is being solved. 
It will also change under-constrained geometry in a particular order. 
The order is chosen so as to change each geometry the minimum amount necessary to satisfy the dimensions. 
For example, if a fixed point and a line are dimensioned to be a certain distance apart then the DCM will translate the line to satisfy the dimension but will not change its angle. 
Generally the DCM will try to maintain the radius of circles and, after this, the angle of lines.

When the standard solving mode is used the DCM takes account of the original location of the geometries. 
Because of this, it is more likely that a solution will be found with this solving mode than with the minimum move and weighted standard solving modes described below.

When using standard solving the application can specify an array of geometries. 
See section [2.5.6.7 Soft reference geometry](#_Ref73871708) for details of how this is used.

#### 2.5.6.2 Weighted standard solving mode

Weighted standard solving differs from standard solving in the way it uses the priority geometry array. 
With standard solving, only three degrees of freedom for each disjoint part are affected by the geometries in the array. 
However, with weighted standard solving the DCM can use all the freedoms of the model to affect the positioning of the geometries in the array. 
In other words, weighted standard solving will position geometry without attempting to maintain a rigid-body appearance of disjoint parts.

This solving mode gives the application much greater control over the positioning of individual geometries. 
In particular, standard solving may only use the first one or two elements in the priority array, but weighted standard solving can position all the geometry in a larger array, subject to a solution being possible.

This solving mode is useful when applications wish to specifically position some geometries in a model. 
This can be when using the evaluate function after geometry is first added or when using the move\_and\_evaluate function to reposition geometry. 
However, the disadvantage of this mode is that it restricts the DCM from finding some solutions. 
This means that there will be some models that would solve in standard mode that will not solve in weighted standard mode. 
Also, the shape of under-constrained parts is more likely to change when several geometries are in the priority array.

[Figure 4: An example of weighted standard solving](#_Ref497716078) shows an example of the difference between standard and weighted standard solving. 
This model contains a fixed geometry (the vertical line) and some under-constrained geometry (the rectangle and point), in the initial solved position. 
If the application moves the point to the right and then evaluates, under standard solving mode it will be snapped back to the original position. 
Even if the point is supplied as a soft reference, the connection to the fixed geometry will override this effect since the DCM will try to maintain the box and point as a rigid entity. 
However, with weighted standard solving, the desired position below can be obtained if the point is supplied to the priority array.

![fig4_weighted.bmp](../Resources/Images/2ddcm_manual/Evaluating the model_2.png)

Figure 4: An example of weighted standard solving

#### 2.5.6.3 Localised solving mode

Localised solving aims to identify the closest geometries to any unsatisfied constraint and any non-rigid dimension or dragged geometry that can be changed to satisfy the constraints and achieve the input transforms, such that more distant model elements will not be changed.

The definition of closest is based primarily on the model connectivity (the number of steps away from the unsatisfied or changing d\_node or changing g\_node) but where necessary, geometric distances are used as well. 
Unlike standard solving, changes are not propagated onto connected geometry.

This solving strategy should result in smaller movements to solve the changes input, with a limited set of g\_nodes being transformed, all of which should be close to the inputs driving the change. 
As a result, it is particularly suited for local changes to large models, where a user might only be viewing a subset of the full DCM model; the changes will be more likely to apply only to those elements visible.

Note that during a DCM evaluation, all geometry positions are calculated, even in this solving mode, so that transforms may be output on any geometry into order to improve the accuracy of constraints. 
However, the majority of these would be expected to be extremely small changes with this mode.

DCM will use the following to decide which geometries should be more likely to move:

- Most importantly, the following "seed" cases, with equal priority:

- Geometry given an input transform (move\_and\_evaluate/dynamic\_evaluate)
- Geometry which has unsatisfied logical constraints
- Geometry with unsatisfied rigid dimensions
- Geometry which has dimensions with a value (whether satisfied or not)

- Geometry near the above "seeds"

- Firstly, measuring by how closely connected the geometries are, in numbers of constraints.
- In the case that this is equal, geometry that is closer in space.
- To avoid asymmetric solving multiple equally distant geometries may both be moved instead of moving just one.

It is not recommended that the application specify any priority geometries or transform biases when using evaluating in this mode. 
The application should allow the DCM to decide which geometries to move.

The treatment of rigid and non-rigid dimensions is of critical importance in getting appropriate behaviour from localised solve mode. 
Applications are expected to use the dimension rigidity to inform DCM about which dimension values are to be considered constant over the course of a sequence of localised solves. 
As noted, all non-rigid dimensions are considered seeds for localising changes: Hence, to get optimum local solving, only those values that will be changes should be left non-rigid, whilst the others should be defined as rigid, just during that solving cycle.

#### 2.5.6.4 Minimum move solving mode

When minimum move solving is specified, the DCM does not propagate geometry transformations through the model. 
Also, it will find a solution that will localise the changes around certain parts of the model. 
The application has the opportunity to specify whereabouts on the model the changes should be localised, or to allow the DCM to make this choice. 
Providing the DCM is allowed to choose, this solving mode will move the minimum number of geometries.

The DCM will use the following to decide which geometries it should move:

- If the model is being dragged, the geometries that are being transformed will be moved in preference to other geometries.
- If a dimension or constraint is not currently satisfied by the position of the geometries, the DCM will preferentially move geometries at the ends of the dimension or constraint.

It is not recommended that the application specify any priority geometries when using evaluating in this mode. 
The application should allow the DCM to decide which geometries to move.

Note that unlike localise solve mode, DCM will make assumptions about whether an application will change a non-rigid (regular) dimension value when solving in minimum move mode. 
If any dimensions are satisfied initially, then the connected geometry will not be considered as likely to move in future incremental solves. 
This may have the effect of causing local computation failures if the dimension values are changed in further steps, but conversely, it allows DCM to minimise changes around unsatisfied dimensions without use of rigid dimensions.

[Figure 5: Effect of different solving modes.](#_Ref497733119) shows the effect of changing a dimension and evaluating with the standard solving mode, and dragging geometry using minimum move solving mode.

![fig5_solving_modes.bmp](../Resources/Images/2ddcm_manual/Evaluating the model_3.png)

Figure 5: Effect of different solving modes.

#### 2.5.6.5 Relaxation solving mode

As its name suggests, the relaxation solving mode will find a solution by a numerical relaxation method. 
The effect of this will normally be that more geometries will move relative to each other than with the other solving modes. 
The algorithm used will attempt to approximately minimise the sum of the squares of the movements and hence will move all geometries by a similar amount.

The advantage of this type of solving is that it will find solutions in cases where the other three modes would not. 
An example of this is a simple chain of bounded lines, where attempting to "stretch" the chain will require that several of the geometries will move. 
Numerical solving is normally slower than any of the other three modes.

Relaxation solving uses the prioritised geometry list as soft references in the same way as standard solving.

#### 2.5.6.6 Transform bias

During an evaluation using any solving mode, the application may use a transform bias to notify the DCM about its preferences for which geometry should be moved and which geometry should not. 
If the DCM determines that it must move geometry then it will enquire a bias type and value for each geometry node that may move. 
This enquiry occurs via the Frustum during the evaluation. 
If possible, the DCM will move geometry according the application’s priorities in order to reach a solved position. 
It is possible, however, that the DCM will override the bias specified if that would have prevented a solution from being found. 
Note that this is only effective for under-defined models where there exists more than one possible solution.

Specifying a transform bias is similar to using the weighted standard solving mode. 
However, it provides more flexibility as it allows the application to specify a complete ordering for the geometries which should move or remain stationary. 
Transform bias can also be supplied for DCM variables in order to influence whether the value will change or not. 
The bias values of variables and geometry are compared equally, so it is possible to use the bias to select whether an equation is solved by moving a geometry or changing a variable.

Transform bias may be used for all solving modes and for any type of evaluation (evaluate, re\_evaluate, dynamic\_evaluate and move\_and\_evaluate). However various limitations apply:

- Transform bias is not recommended with localised solve mode.
- The nature of relaxation solving means that it will be unlikely that the transform bias will have an effect.
- Transform bias will not be enquired for incremental evaluations: For re\_evaluate and dynamic\_evaluate, when an incremental solve is possible, the geometries which move will be determined by the previous full evaluation.
- The movement of geometry specified by the application during dynamic\_evaluate and move\_and\_evaluate will take precedence over any biasing.
- Soft references can override the transform bias and therefore it is not recommended to use both of these features at once.

Frustum functions: [DCM\_g\_transform\_bias](17.12._Miscellaneous_functions.md)

#### 2.5.6.7 Soft reference geometry

In general a DCM model with no fixed geometry will have three degrees of freedom. 
If a model with no fixed geometry is modified (for example, by changing a dimension value) then the application can influence the outcome by using soft reference geometry.

If any geometry is selected as a soft reference this is taken as an indication to the DCM that the geometry should not be changed and if this is not possible then it should be moved as little as necessary. 
Internally, the DCM will solve the model without taking account of any soft references, and will then use any remaining degrees of freedom to attempt to maintain the position of the soft reference geometry. 
That is to say, it may translate or rotate the model but will not actually change its shape.

The DCM is given the soft reference geometry as an array. 
If the DCM has to alter soft reference geometry the first geometry in the array is the least likely to be moved, and the last geometry is the most likely to be moved.

Before soft references are used, the DCM will identify parts of the model that are disjoint. 
If two parts of the model are not connected directly or indirectly by dimensions, then they are disjoint. 
Additionally, parts are disjoint if they are only connected by dimensions to fixed geometry.

The soft reference algorithm is applied to each disjoint part of the model separately, and so an application can specify several soft reference geometries in each disjoint part of the model. 
Once all of these degrees of freedom have been used up any remaining soft reference geometries will be ignored and may be moved by the DCM. 
Typically only a few soft reference geometries will be used for each disjoint part of the model although there is no significant performance overhead if more are specified.

Soft references will also be used in parts of the model where there are some fixed geometries, but there are still some remaining freedoms. 
For example, if a disjoint part has a single fixed point its rotational freedom is still available to satisfy the soft reference geometries.

#### 2.5.6.8 Choosing which solving mode to use

As mentioned above, it is recommended that the default solving modes are used in most cases. 
However, an application is free to choose to use other modes if it gives the required behaviour.

An exception to the above advice would be for dragging: The default, for backwards compatibility, is minimum move mode. 
However, for new integrations, it is believed that localised solving will provide a better experience for most purposes as long as the instructions of defining constant value dimensions as rigid is followed.

All of the solving modes described above only affect under-constrained models. 
Although the DCM has been designed to solve under-constrained models it is usually preferable to add extra dimensions to give the desired behaviour whenever this is possible.

With some under-deifned models, the choice of solving mode will affect whether certain starting positions can yield a successful solve. 
For example, minimum move solving might fail, with statuses of DCM\_NOT\_CONSISTENT, on a model that would solve standard solving, because the solution method chosen only allows for a limited range of movement, whereas moving more geometries would succeed in satisfying all constraints.

### 2.5.7 Problems with the dimensioning scheme

Occasionally the DCM will be unable to compute positions for the geometry to satisfy all the constraints due to problems with the dimensioning scheme. 
In these cases, the DCM will pass appropriate status codes to the application to explain any problem areas. 
The possible problems that may occur include: (see chapter [14\. Status Codes](14._Status_Codes.md)

- Not-consistent \- A design can have the correct number and types of dimensions and yet be not-consistent. 
An example of this is a triangle defined to have sides of length 50, 50 and 120.
- Over-defined \- There are too many dimensions for the available degrees of freedom of the geometries. 
However, as mentioned in section [2.3 Degrees of freedom](2.3._Degrees_of_freedom.md)
See section [2.7.2 Over-constrained but consistent models](2.7._Solving_over-defined_models.md)
- Under-defined \- There are insufficient dimensions or constraints to take up all the available degrees of freedom of the geometries. 
In this case, the DCM can output more detailed information about which degrees of freedom a geometry still has (e.g. 
if the radius of a circle is not defined). Under-defined geometry is not regarded by the DCM as a problem and it will still solve the model.
- Singular under-defined – The model contains geometry that has the right number of constraints to remove all of its freedoms but, because of the particular values of dimensions or positions and shapes of geometry, the geometry can actually be positioned in a range of positions. 
Whilst the DCM does not have a difficulty solving such models, it is not always possible to fully define such geometry by adding further constraints, so applications may need to treat such cases differently to regular under-defined geometry.

The DCM provides functions that allow an application to perform a check before a dimension is added, to see if it will make the data over-constrained. 
These functions operate much faster than actually applying the dimension and then evaluating the geometry normally. 
Also, finding all the over-constrained data in a model is a relatively expensive operation and an option in the DCM allows the application to avoid this analysis if the data is not necessary.

DCM functions: [set\_option](16.2._Configure_global_DCM_behaviour.md)

