## 16.1 寸法システムの構築と削除

以下のセクションでは、寸法システムを開始および停止するための関数、または他の関数の動作を制御するための関数について説明します。

### 16.1.1 dimension\_system - 寸法システムを作成し初期化する

dimension\_system( void\* ap=DCM\_NULL );

dimension\_system( double res\_linear, double size, void\* ap=DCM\_NULL );

DCMは、dimension\_systemクラスのインスタンスを宣言することで初期化されます。
C++では、これによりdimension\_system構造体が定義され、初期化されます。
その後、dimension\_systemのメンバ関数を使用してDCMとやり取りすることができます。
利用可能な関数は以下に説明されています。

注意点として、アプリケーションはこのクラスの複数のインスタンスを同時に使用することができます（たとえば、3次元空間の異なる平面を表すために）。
詳細については、[16.1.5 Multiple DCM instances](#_Ref519601359)のセクションを参照してください。

アプリケーションは、dimension\_systemが作成される際にポインタ値apを渡すことができます。
これを行うと、この特定のdimension\_systemがアプリケーションによって呼び出されたときに、DCMは外部変数DCM\_application\_pointerをこのポインタ値に設定します。
複数のdimension\_systemが作成されている場合、アプリケーションはFrustum関数が呼び出されるたびに外部変数の値を読み取り、どのdimension\_systemが呼び出されたかを判断することができます。
ポインタ値が渡されない場合、外部変数はdimension\_systemポインタの値に設定されます。

必要に応じて、線形解像度とサイズボックスを指定する引数で宣言することもできます。
これらは無次元の値です。単位はアプリケーションによって課せられます。
線形解像度は、2つの点が一致と見なされる距離です。
線形解像度をサイズで割ると、2つの直線が平行と見なされる角度の接線が得られます。
デフォルト値は、解像度に1.0E-8、サイズに1.0E+3です。
したがって、デフォルトの角度解像度は1.0E-11ラジアンです。

DCMは、入力の解像度値をチェックし、無効なデータの場合は例外をスローする代わりに、デフォルトの値を使用します。
これが発生した場合、通常はFrustum関数が最初に登録されたときに、DCM\_debug\_message Frustum関数が呼び出され、アプリケーションに通知されます。
また、そのようなDCMから作成されたジャーナルファイルにも警告が書き込まれます。
このチェックにより、DCMのサポートされる最大サイズ値は現在1E+10ユニットです。
非常に大きなサイズのモデルで作業する顧客は、DCMにデータをロードする際に適切な単位値を採用する必要があります。

詳細については、[2.5.2 Resolution and accuracy](2.5._Evaluating_the_model.md)のセクションを参照してください。

~dimension\_system();

この関数は、クラスdimension\_systemのC++デストラクタです。
この関数は、クラスdimension\_systemのインスタンスがスコープ外になったときに暗黙的に呼び出されます。また、アプリケーションはDCMのインスタンスを削除することで明示的に呼び出すこともできます。
呼び出しの効果は、内部のDCM構造をすべて消去し、その後DCM自体を消去することです。
その後、このクラスのdimension\_systemのインスタンスに対してDCM関数を呼び出す試みは失敗します。

### 16.1.3 フラスタム関数の登録

DCMは、モデルデータをアプリケーションと共有し、フラスタムインターフェースとして知られる一連の関数を介してアプリケーションと通信します。
これらの関数は、システムと一緒に提供されるフラスタムヘッダファイルで定義されています。

DCM\_logical register\_frustum\_functions( DCM\_frustum\_functions\* af );

戻り値は、成功した場合はDCM\_TRUEです。
現在、DCMの評価版のみがDCM\_FALSEを返すことがあります（ライセンスが期限切れの場合）。
将来的には、追加のチェックが導入されるかもしれません。

アプリケーションがこの構造体にすべてのフラスタム関数をコーディングして登録する必要はありません。
特に以下の点に注意してください：

- 一部のフラスタム関数は呼び出されることはありません。たとえば、DCMに方程式が追加されない場合、方程式データを問い合わせるための関数は必要ありません。
- 一部の関数はオプションです。たとえば、DCM\_erased\_nodeは、ノードが消去される予定であることをアプリケーションに通知しますが、アプリケーションはこの情報を必要としない場合があります。
- DCMはデフォルト値を使用することがあります。たとえば、DCM\_resolve\_zero\_diamond関数が利用できない場合、DCMはデフォルト値を使用します。

アプリケーションは、次の関数を呼び出すことで、すでに登録されている関数を問い合わせることができます：

void enquire\_frustum\_functions( DCM\_frustum\_functions\* af );

これは、関数が登録される前に呼び出され、構造体afのすべてのメンバーをNULLに初期化するために推奨されます。
アプリケーションは、これらの関数のアドレスをこの構造体に記入してから登録する必要があります。

DCMは、アプリケーションによって登録されていないフラスタム関数を呼び出そうとし、デフォルトが定義されていない場合（セクション[17.12.5 DCM\_integration\_debug\_message – デバッグメッセージの出力](17.12._Miscellaneous_functions.md)を参照）、登録されているフラスタム関数DCM\_debug\_message（があれば）を呼び出します。

### 16.1.4 数学フラスタム関数の登録

DCMは、数学フラスタム関数を介してアプリケーションが外部の数学関数を登録することを可能にします。
この登録は、メインのDCMフラスタムを介してアプリケーション関数を登録することと類似しています。
これらの関数は、DCMが内部で行うよりも効率的に大規模な行列演算を解決するために、DCMによってオプションで呼び出されます。

アプリケーションがこれらの関数を登録しない場合、DCMは従来のDCM数学関数を使用します。
アプリケーションが外部の数学ライブラリを使用する場合、指定された関数（このバージョンでは合計3つ）をすべて登録する必要があります。
1つ以上が登録されていない場合、従来のDCM数学関数が使用されます。

DCM\_logical register\_maths\_frustum\_functions( DCM\_maths\_frustum\_functions\* mf );

アプリケーションは、標準のLAPACK関数を実装する関数のアドレスと、使用されている実装のバージョンを提供するオプションの関数を含むstruct mf のアドレスを指すポインタを提供します。

typedef struct DCM\_maths\_frustum\_functions

{

DCM\_dgels\_function     dgels;

DCM\_dgesdd\_function   dgesdd;

DCM\_dgesv\_function     dgesv;

DCM\_maths\_get\_version\_function  maths\_get\_version;

} DCM\_maths\_frustum\_functions;

アプリケーションは、この関数で使用されるstructを問い合わせ関数を介して初期化することができます。

DCM\_logical enquire\_maths\_frustum\_functions( DCM\_maths\_frustum\_functions\* mf );

新しい2D DCMオブジェクトの場合、これによりすべてのstructの値がNULLに設定されます。
アプリケーションが以前にフラスタム関数を登録している場合、DCMは渡されたstructの値を以前に登録された値に設定します。
アプリケーションは、新しい2D DCMのバージョンが統合された場合にアプリケーションコードの変更を必要とせずに、将来の追加の関数ポインタが有効な値を持つことを保証するために、常にこの問い合わせ関数を呼び出すことをお勧めします。

詳細は、[17.11 外部数学ライブラリの関数](17.11._Functions_for_external_maths_libraries.md)を参照してください。

### 16.1.5 複数のDCMインスタンス

2D DCMは、複数のインスタンス（dimension\_systemオブジェクト）を持つことができるクラスとして実装されています。この設計により、アプリケーションは異なる目的のために同時に異なるDCMインスタンスを作成し維持することが可能です。
例えば、アプリケーションには3D形状を定義するために使用される複数のスケッチがあるかもしれません。
それぞれのスケッチに対してDCMインスタンスを持つことができ、それらを独立して解決することができ、これらのインスタンスをメモリに永続的に保持することができます。

標準のDCMライブラリは現在スレッドセーフです。マルチスレッドアプリケーションを使用する場合、別のビルドを使用する必要はありません。
これは、アプリケーションが複数のDCMインスタンスを並行して実行し、インスタンスが異なるスレッドで動作することが可能であることを意味します。
ただし、各インスタンスは1つのスレッドによってのみ使用される必要があります - 複数のスレッドが同じDCMインスタンスにアクセスすることはできません。

アプリケーションは、複数のDCMを実行する際に以下のルールに従う必要があります：

- アプリケーションは、DCMのポインタ（例：g\_nodeポインタ）を別のDCMインスタンスに渡してはなりません。
- アプリケーションがDCMを単一スレッド環境で実行している場合、Frustum関数を呼び出しているDCMインスタンスは、グローバル変数DCM\_application\_pointerを介して特定することができます。
ただし、アプリケーションがマルチスレッド環境でDCMを実行している場合、DCM\_application\_pointerは使用されません。
したがって、このような状況では、別の方法を使用してDCMインスタンスを特定する必要があります。
現在のすべてのFrustum関数では、Frustum呼び出し時に渡されるアプリケーションオブジェクトからDCMインスタンスを特定することができます。
コンテキストポインタを渡さない関数は非推奨であり、代替バージョンが利用可能です。
- PGM（Profile Geometry Manager）コンポーネントの標準ビルドはスレッドセーフではありません。
そのため、そのコンポーネントのスレッドセーフなバージョンが別のライブラリ形式で提供されています。
そのPGMビルドは特別な2D DCMビルドを必要とし、標準の2D DCMビルドとは使用することができません。

なお、以前のスレッドセーフライブラリで必要とされていたスレッド登録関数はもはや必要ありません。
これらの関数（DCM\_register\_threadおよびDCM\_unregister\_thread）はインターフェースに残っていますが、呼び出されても効果はありません。
