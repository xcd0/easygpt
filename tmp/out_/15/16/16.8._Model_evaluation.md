## 16.8 モデル評価

以下の関数はモデルを計算するために使用されます。

### 16.8.1 evaluate - 図形を評価する

DCM\_evaluation\_type evaluate( int ng = 0, g\_node\*\* gn = DCM\_NULL,

DCM\_solving\_mode mode = DCM\_STANDARD\_SOLVE );

DCMに対して、図形と変数を再計算し、すべてのエンティティのステータスコードを設定するよう指示します。
この関数には、オプションでDCM図形ノードの配列と、配列の長さに対応する整数を与えることもできます。
これらの使用方法については、以下で説明します。
また、使用する解決モードに影響を与えるためのオプション引数も指定できます。
これには以下の4つの値があります：

- DCM\_STANDARD\_SOLVE \- 標準的な方法を使用して解を求めます（デフォルト）。図形の配列はソフトリファレンス図形の配列として使用され、配列の最初の図形は最も動かない可能性があります。
詳細は[2.5.6.7 ソフトリファレンス図形](2.5._Evaluating_the_model.md)を参照してください。
- DCM\_WEIGHTED\_STANDARD\_SOLVE \- この解決モードは、標準的な解決と同様に動作します。
図形の配列は、アプリケーションがその場に残しておきたい図形を定義するために使用されます。
これは標準的な解決のソフトリファレンス配列のように機能しますが、解決される解により大きな影響を与えます。
つまり、図形を動かす可能性は低くなりますが、有効な解を見つける可能性も低くなります。
この解決モードは、evaluate関数と一緒に使用することはお勧めしません。
- DCM\_MINIMUM\_MOVE\_SOLVE \- この解決モードは、出力される変換の数を最小限に抑える傾向があります。
図形の配列は、図形が移動する優先順位を指定するために使用されます。
配列の最初の図形は最も動く可能性があります。

なお、これはソフトリファレンスとは異なり、配列の最初の図形は最も動かない可能性がある点に注意してください。
アプリケーションがこの解決モードを使用することを決定した場合、evaluate関数に図形を渡さないことをお勧めします。
- DCM\_LOCALISED\_SOLVE \- この解決モードは、システム内の不完全な制約と変更可能な値を持つ寸法の周りで変更を局所化しようとします。
詳細は[2.5.6.3 局所化解決モード](2.5._Evaluating_the_model.md)を参照してください。
このモードを使用する場合、アプリケーションは、ほとんどの寸法を剛体にすることを検討する必要があります。これは、フラスタム関数DCM\_dimension\_rigidを使用して行います（[17.2.22 DCM\_dimension\_rigid - 距離が剛体であるかどうかを返す](17.2._Basic_dimension_functions.md)を参照）。

なお、図形の配列はすべてソフトリファレンスと見なされます。
これらはすべての図形を動かす可能性があるため、このモードではお勧めしません。
- DCM\_RELAXATION\_SOLVE \- 拘束不足の図形に対して緩和解法を使用します。
図形の配列はソフトリファレンスとして使用されます。

この関数は、以下のいずれかの値を返します：

- DCM\_FULL\_EVAL\- モデル全体に対して完全な評価が実行されました。
- DCM\_EVAL\_ABORTED \- アプリケーションによって評価が中断されました。

異なる解決モードの詳細については、[2\. Fundamental DCM Concepts](2._Fundamental_DCM_Concepts.md)を参照してください。

### 16.8.2 re_evaluate - 図形を逐次的に評価する

DCM_evaluation_type re_evaluate(int ng = 0, g_node** gn = DCM_NULL,

DCM_logical calc_status = DCM_FALSE,

DCM_solving_mode mode = DCM_STANDARD_SOLVE);

この関数は、DCMに対して図形の再計算を指示します。
evaluateと同様に、オプションでDCM図形ノードの配列と、配列の長さに対応する整数を指定することができます。
また、必要に応じて詳細なステータス情報を制御するためのオプション引数も指定することができます。
以下にこれらの引数について説明します。

re_evaluateを使用した逐次的な評価は、evaluateを使用した完全な評価よりも高速です。
これは、DCM評価アルゴリズムの後半部分のみを行えば良いためです（DCMは寸法設定の再解析は必要ありません）。
逐次的な評価は、前回の完全な評価以降に寸法が追加または削除されていない場合に可能です。
変更が行われた場合（たとえば、add_dやeraseの呼び出しによって）、re_evaluateを使用すると完全な評価が行われます。
re_evaluateの引数のいずれかが変更された場合も、完全な評価が行われます。

re_evaluateを使用する前に、reset関数を呼び出すことでモデル全体の完全な評価を強制することができます。

この関数は、以下のいずれかの値を返します：

- DCM_FULL_EVAL - モデル全体の完全な評価が行われました。
- DCM_PARTIALLY_INCREMENTAL_EVAL - モデルの一部が逐次的に評価されました。
- DCM_FULLY_INCREMENTAL_EVAL - モデル全体が逐次的に評価されました。
- DCM_EVAL_ABORTED - アプリケーションによって評価が中止されました。

通常、寸法の値を変更した後や、change_chirality関数を使用して異なる解に変更した後に、逐次的な評価が使用されます。
re_evaluateを使用して逐次的な評価を行う場合、ジオメトリの移動は解のキラリティに影響を与えません。
寸法の値を逐次的な解析で変更する場合、寸法は剛体であってはなりません（これがデフォルトです）。
同様に、式に対しては、各ステップで式を変更するためには剛体であってはなりません。

逐次的な評価の前に、アプリケーションによって固定された図形を移動してはならず、DCMはこれが行われたかどうかを検出しません。
固定された図形を移動すると、以前の完全な評価の過程で行われた推論が破綻する可能性があります。
ジオメトリを移動し、キラリティを保持するためには、move_and_evaluate関数を使用することを推奨します。

デフォルトでは、re_evaluateはevaluateと同様にステータスコードを設定しますが、未定義および適切に定義されたジオメトリを未定義としてマークします。
また、ジオメトリに詳細な未定義のステータスコードを設定しません。
オプション引数calc_statusをDCM_TRUEとしてre_evaluateに渡すと、適切に定義されたジオメトリにもステータスコードを設定します。
これを行うと、逐次的な評価にかかる時間は約2倍になりますが、完全な評価にかかる追加時間は約10%増加します。

re_evaluateには、使用する解析モードを指定するさらなるオプション引数を渡すことも可能です。
許可されるもののリストについては、evaluateを参照してください。
re_evaluateはevaluateの呼び出しの後に呼び出される場合、同じ解析モードを使用する必要があります。そうでない場合、re_evaluateは完全な評価を行います。

逐次的な評価がre_evaluateによって行われた場合、undo_evaluation関数を呼び出すことで、ジオメトリを逐次的な評価の前の位置または最後の完全な評価が行われた位置にリセットすることができます。

モデル全体または単一のノードがどのように評価されたかを問い合わせるには、セクション[16.5.17 last_evaluation_type - DCM評価タイプ情報を返す](16.5._Enquiry_functions.md)で説明されているDCM関数last_evaluation_typeを呼び出すことができます。

### 16.8.3 move\_and\_evaluate - 拘束を保持したまま評価する

DCM\_m\_and\_e\_outcome move\_and\_evaluate( int ng, g\_node\*\* gn,

double (\*\*mat)\[3\],

double\* rad = DCM\_NULL, double\* rad2 = DCM\_NULL,

DCM\_solving\_mode = DCM\_WEIGHTED\_STANDARD\_SOLVE );

この関数は、図形を変形して評価することができますが、元の図形の位置と同じキラリティで解を見つけます。

この関数は、DCMの図形ノードの配列と、配列の長さに対応する整数を受け取ります。
変換は、変換行列の配列として与えられます。
詳細は、[15.13 DCM transforms](15.13._DCM_transforms.md)を参照してください。
もし、図形が円または楕円である場合、アプリケーションはngの長さのdoubleの配列を与えることもできます。これには、円の新しい半径と楕円の主半径の新しい値が含まれます。
さらに、楕円の副半径の新しい値を与えるために別の配列を使用することもできます。

この関数が呼び出されると、DCMはまず元のキラリティを記録し、アプリケーションが提供した変換と半径に基づいて図形を変更し、同じキラリティで解を求めます。
固定された図形と同じセット内の図形との制約は、移動後にのみ暗黙的に適用されます。

この関数には、パラメトリックな図形（DCM\_PARAMETRICおよびスプライン曲線）も渡すことができます。
パラメトリック曲線の形状が変わらず、剛体的に移動する場合は、適切な変換を与える必要があります。
ただし、アプリケーションがパラメトリック曲線の形状を変更したい場合は、変更された手順が必要です。

パラメトリック曲線の形状が変更されることをDCMに通知するために、次の手順が実行されます。

- move\_and\_evaluateの呼び出しの開始時に、DCM\_PARAMETRIC曲線のアプリケーション評価器を設定して、曲線の開始位置と形状を返すようにします。
- スプライン曲線の場合、新しい補間点または制御点がg\_nodesとして指定される場合、アプリケーションはmove\_and\_evaluateを呼び出す前にg\_nodesをDCMに追加する必要があります。
- move\_and\_evaluateを呼び出す際には、次の手順を実行します。

- アプリケーションは、通常どおりDCMの図形ポインタをgnの図形配列に入れます。
- 変換行列の配列matは、パラメトリック曲線または曲線に対応する場所にDCM\_NULLの値を持つ必要があります。
例えば、[15.13 DCM transforms](15.13._DCM_transforms.md)のコードを参照してください。

- move\_and\_evaluate中、DCMは最初にこれらの曲線の開始バージョンを問い合わせ、使用して初期キラリティを確立します。
- ある時点で、DCMはフラスタムに対して、アプリケーションにパラメトリック曲線を所望の最終形状と位置に変更するように要求します。
具体的な呼び出しは、曲線のタイプによって異なります。

- DCM\_PARAMETRIC曲線の場合、フラスタム関数DCM\_parametric\_regenerateが呼び出されます。これは、依存するジオメトリがない曲線でも呼び出されます。この関数が呼び出されるたびに、アプリケーションは曲線の評価器を所望の最終形状に設定する必要があります。通常のように、アプリケーションは変換関数を使用して依存するジオメトリの現在の位置を問い合わせるべきです。解決プロセス中、DCMはさらにDCM\_parametric\_undo\_regenerateを呼び出して、アプリケーションに一時的に評価器を元の開始形状に戻すように指示する場合があります。
- スプライン曲線の場合、フラスタム関数DCM\_spline\_updateが呼び出されます。その後、アプリケーションはreplace\_splineまたはupdate\_splineのいずれかを呼び出して、対象のスプラインに新しいスプラインデータを供給する必要があります。update\_spline関数は、少ない情報をDCMに渡す必要があるため、細かい変更が必要な場合に使用できます。一方、replace\_spline関数は、制御点や補間点の追加を含むより基本的なプロパティの変更を許可します。2つの関数が許可する変更の詳細については、フラスタム関数の定義を参照してください。

- 新しい曲線定義が提供された後、DCMは新しい曲線の形状と位置を使用して評価を完了します。解が正常に完了できない場合（例：一貫性のないモデルになる場合）でも、パラメトリック曲線の位置は関数中で指定された最終位置となります。
- パラメトリックジオメトリには変換は出力されません。

この関数は、次のいずれかを返します。

- DCM\_M\_AND\_E\_SOLVED\_EXACTLY

すべての図形が解決され、移動した図形が要求された位置に配置されました。
- DCM\_M\_AND\_E\_SOLVED

すべての図形が解決されましたが、リストされた図形の一部が要求された位置から移動されました。たとえば、関数に定義された明確な自由なジオメトリのみが渡された場合、解は唯一の解を見つけるためにジオメトリを初期位置に戻す必要があります。
- DCM\_M\_AND\_E\_FAILED

DCMは、図形を変形した位置でモデルの解を見つけることができませんでした。これは通常、アプリケーションが図形を「あまりにも遠く」移動しようとしたためです。その結果、一部の図形にはNOT\_CHANGEDまたはNOT\_CONSISTENTのステータスコードが付いています。move\_and\_evaluateに渡された固定された図形は、要求どおりに変形されているため、モデルのキラリティが変わっている可能性があります。この場合、アプリケーションはundo\_evaluationを呼び出してジオメトリの元の状態を復元する必要があります。

なお、この呼び出し中にパラメトリックまたはスプラインの定義がアプリケーションによって変更された場合、undo\_evaluation関数はこの変更を元に戻しません。したがって、DCM\_PARAMETRIC曲線の評価器を変更するか、スプライン曲線のreplace\_spline / update\_splineを呼び出すことで、アプリケーションがこれを行う必要があります。

このmove\_and\_evaluate関数は、いずれの解決モードも使用できます。重み付け標準解決モードがデフォルトです。このモードでは、自由なジオメトリを新しい位置に移動させ、DCM\_M\_AND\_E\_SOLVED\_EXACTLYを返す可能性が高くなります。

16.8.4変更 - DCMに変更されたノードを通知する

void changed( d\_node\* dn, DCM\_changed\_longevity longevity );

void changed( r\_node\* rn, DCM\_changed\_longevity longevity );

void changed( e\_node\* en, DCM\_changed\_longevity longevity );

void changed( g\_node\* gn, DCM\_changed\_longevity longevity );

void changed( p\_node\* pn, DCM\_changed\_longevity longevity );

これらの関数は、アプリケーションによって寸法値、方程式、または図形ノードが変更された場合に、DCMに通知するために特定の状況で使用されます。これにより、DCMは後続の操作にこれを考慮に入れ、re\_evaluateの呼び出しの効率を向上させることができます。

この関数は、変更されるノードと、それがどのように変更されたかを示す引数とともに呼び出されます。
この引数には2つの値があります。

- CHANGED\_UNTIL\_RE\_EVALUATE - re\_evaluateの各呼び出しごとに異なるノードが変更される場合に使用されます。
- CHANGED\_UNTIL\_EVALUATE - 同じノードが繰り返し変更される場合に使用されます。この値が使用される場合、re\_evaluateの呼び出しの連続の最初に、各ノードに対して一度だけchangedを呼び出す必要があります。

パフォーマンスは、re\_evaluate関数が少なくとも2回呼び出される場合にのみ、changed関数を使用することで改善されます。

アプリケーションがこの関数を使用する場合、変更されるすべてのノードに対して呼び出すことが重要です。つまり、この関数が任意のノードに対して呼び出される場合、DCMは他のノードが変更されていないと仮定します。

この関数は、DCMの外部でモデルを変更する際の増分評価中に実行できない変更を通知するために呼び出された場合、効果はありません（[2.5.3.3 DCMの外部でモデルを変更した後の増分評価](2.5._Evaluating_the_model.md)を参照）。

アプリケーションは、ドラッグシーケンス中にd\_node（またはr\_node）でchangedを呼び出すことができます。
d\_nodeにCHANGE\_UNTIL\_RE\_EVALUATEの値でchangedが呼び出された場合、その情報は次のドラッグステップでのみ使用され、その後クリアされます。
CHANGE\_UNTIL\_EVALUATEが呼び出された場合、次の完全評価後にのみクリアされます。
ドラッグシーケンスの最初の評価は完全評価であり、したがって最初のドラッグステップ後にすべてのchangedステータスがクリアされます。
特に、アプリケーションが「changed」情報をドラッグシーケンス全体で適用したい場合は、最初のドラッグステップの後にchangedを呼び出す必要があります。

この関数は、モデルの大部分が変更されることなく、モデルの一部のみが変化する場合に、増分解決中の重要な最適化を提供します。
ただし、re\_evaluateとdynamic\_evaluateとの組み合わせでこの関数を使用しても、モデル全体の初期解決を防ぐことはできません。これは、初期のドラッグステップが遅くなる可能性があります。

さらに、変更された箇所の解決をさらに最適化するために、DCMはパーティション固有の解決関数（re\_evaluate\_partitionsおよびdynamic\_evaluate\_partitions）を提供しており、指定されたノードを解決するために必要なモデルの一部のみを処理します。

### 16.8.5 リセット - インクリメンタル評価を防止する

void reset( DCM\_logical cancel\_chirality = DCM\_FALSE );

DCMに対して、次にre\_evaluateが呼び出される際にインクリメンタル評価を行わないように指示します。
この関数は、アプリケーションがフル評価を行う必要がある場合に呼び出すことができます。たとえば、解のキラリティを変更するためにジオメトリが移動した場合などです。

この関数には、オプションの論理引数も指定できます。
これがDCM\_TRUEの場合、change\_chiralityの呼び出しによってキラリティを変更するための保留中のリクエストもすべて削除されます。

### 16.8.6 リセット - 特定のパーティションでの増分評価を防止する

void reset(g\_node\* gn);

void reset(d\_node\* dn);

void reset(r\_node\* rn);

void reset(e\_node\* en);

void reset(v\_node\* vn);

void reset(p\_node\* pn);

これらの関数は、指定されたノードを含むパーティションでの増分評価をDCMに行わせないように指示します。

この関数は、アプリケーションがモデルの一部を完全に評価する必要がある場合（例：解のキラリティを変更するためにジオメトリが移動された場合など）に、他のパーティションを増分的に解決するようにDCMに指示するために呼び出すことができます。

### 16.8.7 change\_chirality - キラリティの変更

DCM\_chirality\_status change\_chirality( d\_node\* dn, g\_node\* gn1 = DCM\_NULL ,

      g\_node\* gn2 = DCM\_NULL);

この関数は、解のキラリティを変更するために呼び出されます。
呼び出しは、次の評価関数（evaluate、re\_evaluate、dynamic\_evaluate、move\_and\_evaluate、evaluate\_partitionsなど）の次回の呼び出し時に効果が現れます。
変更をまとめて評価する前に、この関数を異なる引数で複数回呼び出すことができます。

DCMの寸法ノードが渡され、オプションで1つまたは2つのDCMの図形ノードが渡されます。
この関数を呼び出すことによる効果は次のとおりです。

- 寸法ノードで呼び出された場合：寸法ノードは、数値のある距離または方向付き距離寸法である必要があります。
DCMは、指定された寸法を反転します。
- 寸法ノードと図形ノードで呼び出された場合：図形ノードは円である必要があり、寸法ノードは距離寸法、方向付き距離寸法、円に対する共有制約または接線制約である必要があります。
共有制約の場合、他の図形は点である必要があります。
DCMは、寸法の補助点を円の反対側に移動することで、寸法を変更します。
- 寸法ノードと2つの図形ノードで呼び出された場合：寸法ノードはDCM\_EQUAL\_DISTANCE型であり、2つの図形ノードは等距離制約が追加されたときに使用される図形ノードのペアの1つである必要があります。
等距離制約のキラリティは、change\_chiralityを使用するのではなく、frustum関数[DCM\_equal\_distance\_half\_space](17.2._Basic_dimension_functions.md)を使用して制約された距離の半空間を設定することによって最もよく制御できます。

モデルがD\_OVER\_DEFINED、D\_NON\_ALGEBRAIC、D\_NOT\_CHANGEDのステータスを持つ場合、モデルは変更されません。

この関数は、与えられた変更が図形の相対位置に変化をもたらすかどうかを示す値を返します。
DCMが「評価済み」の状態ではない場合（つまり、最後の評価関数の呼び出し以降に何らかの変更が加えられた場合）、変化が発生するかどうかを予測することはできません。
評価済みの状態である場合、キラリティの変更が結果にどのような影響を与えるかを予測しようとします。
返される値は次のとおりです。

- DCM\_CHIRALITY\_UNKNOWN \- 要求されたキラリティの変更が変化を引き起こすかどうかを判断できません。つまり、モデルは評価済みの状態ではありません。
- DCM\_CHIRALITY\_NO\_CHANGE \- 要求により変化は発生しません。例えば、2つの点間の寸法など、単一の解しか存在しない場合に返されます。
- DCM\_CHIRALITY\_CHANGE \- 変化が発生します（ただし、以下を参照）。点と線の間の距離寸法など、2つの可能な解が存在する場合に返されます。

DCMが変化が発生する可能性があると示していても、与えられた寸法値では実際の解が存在しない場合があります。
また、DCMが変化が予測されるが、解の対称性のために図形が同じ位置になる場合もあります。
これは、点と線の間のゼロ値の距離寸法などの例です。

等距離制約が変更されている場合、適切な解が見つかる場合にDCMがDCM\_CHIRALITY\_NO\_CHANGEを返すことがあります。
これは、change\_chiralityへの呼び出しで指定された特定の図形ノードのペアが等距離の値を定義するために使用される場合に発生します。
等距離で制約されるすべての図形ペアは、1つの図形ノードの間に変数でない距離が存在する場合に変更できます。

関数resetを使用して、キラリティの変更のすべての保留中のリクエストをキャンセルすることができます。

### 16.8.8 undo_evaluation - モデルを以前の状態に戻す

void undo_evaluation( DCM_undo_mode um );

図形を以前の状態に変換します。
復元される状態は引数（um）で定義されます。

- DCM_UNDO_TO_INITIAL \- 最後の完全評価の前の位置に戻す。
- DCM_UNDO_TO_PREVIOUS \- 最後の増分評価の前の位置に戻す。

元の変換の逆を使用して、undoを実行します。

最後の評価以降に作成された図形は影響を受けません。
すべてのノードのステータスコードも、以前の状態で保持していた値にリセットされます。

モデルがパーティション固有の解決関数を使用して解決されている場合、図形の以前の位置は各個別のパーティションの状態に応じて設定されます。

### 16.8.9 is\_evaluated – 現在の状態をクエリする

DCM\_evaluated\_outcome is\_evaluated();

この関数は、2D DCMの現在の状態を問い合わせるために使用されます。
モデルが評価された状態である場合、関数はDCM\_EVALUATED\_FULLYを返します。
モデルが最後の評価以降に変更されている場合、関数はDCM\_EVALUATED\_NONEを返します。

パーティション固有の解決が使用されている場合、新しい関数はこれを考慮に入れます。
モデルの一部のパーティションが評価された状態であり、他のパーティションが評価されていない場合、返り値はDCM\_EVALUATED\_PARTIALLYになります。
